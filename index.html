<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <title>Backrooms: Gold Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; user-select: none; }
        
        /* Sinematik Görünüm */
        canvas { display: block; filter: contrast(1.1) brightness(0.9) sepia(0.3); }

        /* TAM EKRAN BUTONU (SOL ÜST) */
        #fs-btn {
            position: absolute; top: 20px; left: 20px; z-index: 1000;
            background: rgba(0, 0, 0, 0.5); color: #0f0; border: 1px solid #0f0;
            padding: 10px 15px; cursor: pointer; font-family: inherit; font-weight: bold;
            transition: 0.2s; text-transform: uppercase; font-size: 14px;
        }
        #fs-btn:hover { background: #0f0; color: #000; box-shadow: 0 0 10px #0f0; }

        /* --- MENÜLER --- */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #080808;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 50; color: #ddd;
        }

        h1 { font-size: 80px; margin: 0 0 20px 0; text-shadow: 0 0 15px #a00; color: #a00; letter-spacing: 5px; }
        
        .btn {
            padding: 15px 40px; font-size: 24px; background: #222; color: #fff;
            border: 1px solid #555; cursor: pointer; margin: 10px;
            font-family: inherit; text-transform: uppercase; transition: 0.2s;
            min-width: 250px;
        }
        .btn:hover { background: #a00; color: #000; border-color: #f00; }

        /* SETUP EKRANI */
        #setup-panel {
            background: #151515; border: 1px solid #333; padding: 40px;
            display: flex; flex-direction: column; gap: 20px; width: 500px;
        }
        .player-row { display: flex; justify-content: space-between; align-items: center; }
        .player-row label { font-size: 24px; font-weight: bold; }
        
        select { 
            padding: 10px; font-size: 18px; background: #000; color: #0f0; border: 1px solid #333; 
            width: 250px; font-family: inherit; cursor: pointer;
        }
        select option { background: #111; color: #fff; padding: 10px; }

        /* OYUN ARAYÜZÜ */
        #ui-layer { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .crosshair {
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
            background: #0f0; border-radius: 50%; box-shadow: 0 0 5px #0f0;
            transform: translate(-50%, -50%);
        }
        .hud-text {
            position: absolute; bottom: 30px; left: 30px;
            font-size: 36px; font-weight: bold; color: #a00;
            text-shadow: 2px 2px 0 #000;
        }

        /* ÖLÜM EKRANI */
        #death-screen {
            background: rgba(50, 0, 0, 0.8);
            display: none; z-index: 60;
        }
    </style>
</head>
<body>

    <button id="fs-btn" onclick="toggleFullScreen()">[ ⛶ ] TAM EKRAN</button>

    <div id="menu-screen" class="screen">
        <h1>BACKROOMS</h1>
        <p style="color:#666;">SONSUZLUK SİMÜLASYONU</p>
        <button class="btn" onclick="goToSetup(1)">TEK OYUNCU</button>
        <button class="btn" onclick="goToSetup(2)">2 OYUNCU</button>
    </div>

    <div id="setup-screen" class="screen" style="display:none;">
        <h1>KONTROL SEÇİMİ</h1>
        <div id="setup-panel">
            <div class="player-row">
                <label style="color:#0ff;">OYUNCU 1</label>
                <select id="p1-input">
                    <option value="keyboard">Klavye & Mouse</option>
                </select>
            </div>
            <div class="player-row" id="p2-row">
                <label style="color:#f0f;">OYUNCU 2</label>
                <select id="p2-input">
                    <option value="keyboard">Klavye & Mouse</option>
                </select>
            </div>
        </div>
        <button class="btn" onclick="startGame()">BAŞLAT</button>
        <p style="font-size:12px; color:#444; margin-top:10px;">* Gamepad bağlandığında liste otomatik güncellenir.</p>
    </div>

    <div id="ui-layer">
        <div id="p1-hud" style="position:absolute; top:0; left:0; width:100%; height:100%;">
            <div class="crosshair"></div>
            <div class="hud-text" id="hp1">HP: 100</div>
        </div>
        <div id="p2-hud" style="position:absolute; top:0; left:50%; width:50%; height:100%; display:none; border-left:2px solid #555;">
            <div class="crosshair"></div>
            <div class="hud-text" id="hp2" style="color:#f0f;">HP: 100</div>
        </div>
    </div>

    <div id="death-screen" class="screen">
        <h1>ÖLDÜN!</h1>
        <button class="btn" onclick="respawn()">YENİDEN DOĞ</button>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.128.0/build/three.module.js';

        // --- AYARLAR ---
        const RENDER_DISTANCE = 80;
        const ZOMBIE_COUNT = 15;
        const GRAY_COLOR = 0x444444;

        // --- GLOBAL ---
        let scene, renderer;
        let players = [];
        let bullets = [];
        let zombies = [];
        let walls = [];
        
        let lastTime = 0;
        let selectedMode = 1; 
        const keys = {};

        // --- TAM EKRAN FONKSİYONU ---
        window.toggleFullScreen = function() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Hata: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        };

        // --- MENÜ YÖNETİMİ ---
        window.goToSetup = function(mode) {
            selectedMode = mode;
            document.getElementById('menu-screen').style.display = 'none';
            document.getElementById('setup-screen').style.display = 'flex';
            
            if(mode === 1) document.getElementById('p2-row').style.display = 'none';
            else document.getElementById('p2-row').style.display = 'flex';

            updateControllerList();
            setInterval(updateControllerList, 1000);
        };

        function updateControllerList() {
            const gps = navigator.getGamepads ? navigator.getGamepads() : [];
            const selects = [document.getElementById('p1-input'), document.getElementById('p2-input')];
            const currentVals = [selects[0].value, selects[1].value];

            selects.forEach(sel => {
                let html = `<option value="keyboard">Klavye & Mouse</option>`;
                for(let i=0; i<gps.length; i++) {
                    if(gps[i]) {
                        html += `<option value="${i}">Gamepad ${i+1}</option>`;
                    }
                }
                sel.innerHTML = html;
            });

            if(currentVals[0]) selects[0].value = currentVals[0];
            if(currentVals[1]) selects[1].value = currentVals[1];
        }

        window.startGame = function() {
            document.getElementById('setup-screen').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block';

            if (selectedMode === 1) {
                document.getElementById('p1-hud').style.width = '100%';
                document.getElementById('p2-hud').style.display = 'none';
            } else {
                document.getElementById('p1-hud').style.width = '50%';
                document.getElementById('p2-hud').style.display = 'block';
            }

            initThreeJS();

            const p1Type = document.getElementById('p1-input').value;
            const p2Type = document.getElementById('p2-input').value;
            
            if (p1Type === 'keyboard' || (selectedMode === 2 && p2Type === 'keyboard')) {
                document.body.requestPointerLock();
                document.addEventListener('click', () => {
                    // Oyun içi tıklayınca mouse'u tekrar kilitle (Eğer ölüm ekranı yoksa)
                    if(document.getElementById('death-screen').style.display === 'none') 
                        document.body.requestPointerLock();
                });
            }
        };

        window.respawn = function() {
            document.getElementById('death-screen').style.display = 'none';
            document.body.requestPointerLock();
            
            players.forEach(p => {
                if (p.hp <= 0) {
                    p.hp = 100;
                    p.mesh.position.set(0, 2, 0); 
                    p.velocity.set(0,0,0);
                    p.dead = false;
                    p.mesh.rotation.z = 0; 
                }
                updateHUD(p.id, 100);
            });
            zombies.forEach(z => z.respawn());
        };

        // --- OYUN MOTORU ---
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.fog = new THREE.Fog(0x111111, 10, RENDER_DISTANCE);

            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClear = false;
            document.body.appendChild(renderer.domElement);

            createWorld();

            const aspect = selectedMode === 1 ? window.innerWidth/window.innerHeight : (window.innerWidth/2)/window.innerHeight;
            
            const p1Input = document.getElementById('p1-input').value;
            players.push(new Player(0, 0x00ffff, p1Input, aspect));

            if (selectedMode === 2) {
                const p2Input = document.getElementById('p2-input').value;
                players.push(new Player(1, 0xff00ff, p2Input, aspect));
                players[1].mesh.position.x = 3; 
            }

            document.addEventListener('keydown', e => keys[e.code] = true);
            document.addEventListener('keyup', e => keys[e.code] = false);
            document.addEventListener('mousemove', e => {
                if (document.pointerLockElement === document.body) {
                    players.forEach(p => {
                        if (p.inputType === 'keyboard' && !p.dead) p.mouseLook(e.movementX, e.movementY);
                    });
                }
            });
            document.addEventListener('mousedown', () => {
                if (document.pointerLockElement === document.body) {
                    players.forEach(p => {
                        if (p.inputType === 'keyboard' && !p.dead) p.tryShoot();
                    });
                }
            });

            requestAnimationFrame(animate);
        }

        // --- SINIFLAR ---
        class Player {
            constructor(id, color, inputType, aspect) {
                this.id = id;
                this.inputType = inputType;
                this.hp = 100;
                this.dead = false;
                
                this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
                this.pitch = 0;
                this.yaw = 0;
                this.velocity = new THREE.Vector3();
                this.isGrounded = false;

                this.mesh = new THREE.Group();
                this.mesh.position.y = 2;
                scene.add(this.mesh);

                this.light = new THREE.SpotLight(0xffffaa, 3, RENDER_DISTANCE, Math.PI/5, 0.5);
                this.light.position.set(0,0,0);
                this.light.target = new THREE.Object3D();
                this.light.target.position.set(0,0,-5);
                
                this.camera.add(this.light);
                this.camera.add(this.light.target);
                scene.add(this.camera);

                this.shootCooldown = 0;
            }

            update(dt) {
                if (this.dead) return;

                let moveX = 0, moveZ = 0, rotX = 0, rotY = 0;
                let jump = false, shoot = false;

                if (this.inputType === 'keyboard') {
                    if (keys['KeyW']) moveZ = -1;
                    if (keys['KeyS']) moveZ = 1;
                    if (keys['KeyA']) moveX = -1;
                    if (keys['KeyD']) moveX = 1;
                    if (keys['Space']) jump = true;
                } else {
                    const gp = navigator.getGamepads()[parseInt(this.inputType)];
                    if (gp) {
                        if (Math.abs(gp.axes[0]) > 0.1) moveX = gp.axes[0];
                        if (Math.abs(gp.axes[1]) > 0.1) moveZ = gp.axes[1];
                        if (Math.abs(gp.axes[2]) > 0.1) rotX = gp.axes[2] * 2.0;
                        if (Math.abs(gp.axes[3]) > 0.1) rotY = gp.axes[3] * 1.5;
                        if (gp.buttons[0].pressed) jump = true;
                        if (gp.buttons[7].pressed || gp.buttons[5].pressed) shoot = true;
                    }
                }

                this.yaw -= rotX * dt;
                this.pitch -= rotY * dt;
                this.pitch = Math.max(-1.5, Math.min(1.5, this.pitch));

                const speed = 12 * dt;
                const dir = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), this.yaw);
                const side = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), this.yaw);
                
                const moveVec = new THREE.Vector3();
                moveVec.add(dir.multiplyScalar(-moveZ));
                moveVec.add(side.multiplyScalar(moveX));

                const nextPos = this.mesh.position.clone().add(moveVec.clone().multiplyScalar(speed));
                if (!checkWallCollision(nextPos)) {
                    this.mesh.position.add(moveVec.multiplyScalar(speed));
                }

                if (jump && this.isGrounded) {
                    this.velocity.y = 12;
                    this.isGrounded = false;
                }
                this.velocity.y -= 30 * dt;
                this.mesh.position.y += this.velocity.y * dt;

                if (this.mesh.position.y < 2) {
                    this.mesh.position.y = 2;
                    this.velocity.y = 0;
                    this.isGrounded = true;
                }

                this.camera.position.copy(this.mesh.position);
                this.camera.rotation.set(this.pitch, this.yaw, 0, 'YXZ');

                if (shoot) this.tryShoot();
                if (this.shootCooldown > 0) this.shootCooldown -= dt;
            }

            mouseLook(mx, my) {
                this.yaw -= mx * 0.002;
                this.pitch -= my * 0.002;
                this.pitch = Math.max(-1.5, Math.min(1.5, this.pitch));
            }

            tryShoot() {
                if (this.shootCooldown <= 0) {
                    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(this.camera.quaternion);
                    const bGeo = new THREE.BoxGeometry(0.05, 0.05, 1);
                    const bMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                    const bullet = new THREE.Mesh(bGeo, bMat);
                    
                    bullet.position.copy(this.camera.position).add(dir.clone().multiplyScalar(1));
                    bullet.quaternion.copy(this.camera.quaternion);
                    bullet.userData = { vel: dir.multiplyScalar(80), life: 1.0 };
                    
                    const flash = new THREE.PointLight(0xffff00, 1, 4);
                    flash.position.copy(bullet.position);
                    scene.add(flash);
                    setTimeout(()=>scene.remove(flash), 50);

                    scene.add(bullet);
                    bullets.push(bullet);
                    this.shootCooldown = 0.15;
                }
            }

            takeDamage(amount) {
                if (this.dead) return;
                this.hp -= amount;
                updateHUD(this.id, this.hp);

                if (this.hp <= 0) {
                    this.dead = true;
                    this.mesh.rotation.z = Math.PI / 2; 
                    this.mesh.position.y = 0.5;
                    
                    const allDead = players.every(p => p.dead);
                    if (allDead) {
                        setTimeout(() => {
                            document.exitPointerLock();
                            document.getElementById('death-screen').style.display = 'flex';
                        }, 1000);
                    }
                }
            }
        }

        class Zombie {
            constructor() {
                const geo = new THREE.BoxGeometry(1, 2.5, 1);
                const mat = new THREE.MeshStandardMaterial({ color: 0x111, emissive: 0xaa0000, emissiveIntensity: 0.3 });
                this.mesh = new THREE.Mesh(geo, mat);
                this.respawn();
                scene.add(this.mesh);
                this.speed = 4 + Math.random() * 3;
            }

            respawn() {
                this.hp = 3;
                const livePlayers = players.filter(p => !p.dead);
                if (livePlayers.length === 0) return;
                
                const target = livePlayers[Math.floor(Math.random() * livePlayers.length)];
                const angle = Math.random() * Math.PI * 2;
                const dist = 30 + Math.random() * 20;
                
                this.mesh.position.x = target.mesh.position.x + Math.cos(angle) * dist;
                this.mesh.position.z = target.mesh.position.z + Math.sin(angle) * dist;
                this.mesh.position.y = 1.25;
            }

            update(dt) {
                let target = null;
                let minD = Infinity;
                players.forEach(p => {
                    if (!p.dead) {
                        const d = this.mesh.position.distanceTo(p.mesh.position);
                        if (d < minD) { minD = d; target = p; }
                    }
                });

                if (target) {
                    this.mesh.lookAt(target.mesh.position.x, 1.25, target.mesh.position.z);
                    const dir = new THREE.Vector3();
                    this.mesh.getWorldDirection(dir);
                    this.mesh.position.add(dir.multiplyScalar(this.speed * dt));
                    if (minD < 1.5) {
                        target.takeDamage(1); 
                        this.mesh.position.add(dir.negate().multiplyScalar(0.2));
                    }
                }
            }
        }

        function createWorld() {
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({ color: GRAY_COLOR, roughness: 0.8 }));
            floor.rotation.x = -Math.PI/2; floor.name = "floor"; scene.add(floor);

            const boxGeo = new THREE.BoxGeometry(4, 8, 4);
            const boxMat = new THREE.MeshStandardMaterial({ color: GRAY_COLOR });
            
            for(let i=0; i<150; i++) {
                const wall = new THREE.Mesh(boxGeo, boxMat);
                randomizeWall(wall, {x:0, z:0});
                scene.add(wall);
                walls.push(wall);
            }
            scene.add(new THREE.AmbientLight(0x333));
        }

        function randomizeWall(wall, center) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 10 + Math.random() * RENDER_DISTANCE;
            wall.position.set(center.x + Math.cos(angle)*dist, 4, center.z + Math.sin(angle)*dist);
        }

        function checkWallCollision(pos) {
            for (let wall of walls) {
                const dx = pos.x - wall.position.x;
                const dz = pos.z - wall.position.z;
                if (Math.sqrt(dx*dx + dz*dz) < 2.5) return true;
            }
            return false;
        }

        function updateHUD(pid, hp) {
            const el = document.getElementById('hp' + (pid+1));
            if(el) el.innerText = "HP: " + Math.ceil(Math.max(0, hp));
        }

        function animate(time) {
            const dt = (time - lastTime) / 1000;
            lastTime = time;

            if (zombies.length < ZOMBIE_COUNT) zombies.push(new Zombie());

            players.forEach(p => p.update(dt));
            
            const refPlayer = players.find(p => !p.dead) || players[0];
            if (refPlayer) {
                const center = refPlayer.mesh.position;
                const floor = scene.getObjectByName("floor");
                if(floor) { floor.position.x = center.x; floor.position.z = center.z; }
                
                walls.forEach(w => {
                    if (w.position.distanceTo(center) > RENDER_DISTANCE) randomizeWall(w, center);
                });

                zombies.forEach((z, i) => {
                    z.update(dt);
                    if (z.mesh.position.distanceTo(center) > RENDER_DISTANCE + 10) z.respawn();
                });
            }

            bullets.forEach((b, i) => {
                b.position.add(b.userData.vel.clone().multiplyScalar(dt));
                b.userData.life -= dt;
                let hit = false;
                for(let z of zombies) {
                    if(b.position.distanceTo(z.mesh.position) < 1.5) {
                        z.hp--;
                        hit = true;
                        if(z.hp <= 0) z.respawn();
                        break;
                    }
                }
                if(hit || b.userData.life <= 0) { scene.remove(b); bullets.splice(i, 1); }
            });

            renderer.clear();
            if (selectedMode === 1 && players[0]) {
                renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
                renderer.setScissor(0, 0, window.innerWidth, window.innerHeight);
                renderer.setScissorTest(false);
                renderer.render(scene, players[0].camera);
            } else if (selectedMode === 2) {
                const w = window.innerWidth, h = window.innerHeight;
                renderer.setScissorTest(true);
                if(players[0]) {
                    renderer.setViewport(0, 0, w/2, h);
                    renderer.setScissor(0, 0, w/2, h);
                    renderer.render(scene, players[0].camera);
                }
                if(players[1]) {
                    renderer.setViewport(w/2, 0, w/2, h);
                    renderer.setScissor(w/2, 0, w/2, h);
                    renderer.render(scene, players[1].camera);
                }
            }

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(players[0]) players[0].camera.aspect = selectedMode === 1 ? window.innerWidth/window.innerHeight : (window.innerWidth/2)/window.innerHeight;
            if(players[1]) players[1].camera.aspect = (window.innerWidth/2)/window.innerHeight;
            if(players[0]) players[0].camera.updateProjectionMatrix();
            if(players[1]) players[1].camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>
