<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Backrooms: MCPE Survival (FIXED)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; touch-action: none; }
        
        /* UI */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }

        /* JOYSTICK (SOL) */
        #joystick-zone {
            position: absolute; bottom: 50px; left: 50px;
            width: 140px; height: 140px;
            background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255,255,255,0.2);
            border-radius: 50%; pointer-events: auto; touch-action: none;
        }
        #joystick-knob {
            position: absolute; top: 50%; left: 50%; width: 60px; height: 60px;
            background: rgba(255, 200, 0, 0.6); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            box-shadow: 0 0 15px rgba(255, 200, 0, 0.4);
        }

        /* BUTTONS (SAĞ) */
        #touch-right-zone {
            position: absolute; top: 0; right: 0; width: 50%; height: 100%;
            pointer-events: auto; z-index: 20; touch-action: none;
        }
        
        #btn-jump {
            position: absolute; bottom: 60px; right: 40px;
            width: 90px; height: 90px; border-radius: 50%;
            background: rgba(200, 200, 200, 0.3); border: 2px solid rgba(255,255,255,0.4);
            pointer-events: auto; z-index: 30;
        }
        #btn-jump:active { background: rgba(255,255,255,0.6); transform: scale(0.95); }

        /* SALDIRI BUTONU */
        #btn-attack {
            position: absolute; bottom: 60px; right: 150px; 
            width: 70px; height: 70px; border-radius: 50%;
            background: rgba(255, 50, 50, 0.4); border: 2px solid rgba(255,200,200,0.4);
            pointer-events: auto; z-index: 30;
            display: flex; align-items: center; justify-content: center;
            color: white; font-weight: bold; font-size: 12px;
        }
        #btn-attack:active { background: rgba(255, 0, 0, 0.6); transform: scale(0.95); }

        /* MENU */
        #menu {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: #111; color: #ffea00; z-index: 1000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        .btn {
            padding: 20px 40px; font-size: 20px; background: #333; color: white;
            border: 2px solid #555; margin: 10px; border-radius: 10px; cursor: pointer; width: 80%; max-width: 300px;
        }
        .active-slot { border-color: #0f0; background: #003300; }
        
        #split-line { position: absolute; left: 50%; top: 0; width: 3px; height: 100%; background: #000; display: none; z-index: 5; transform: translateX(-50%); }
    </style>
</head>
<body>

    <div id="split-line"></div>

    <div id="touch-ui" style="display:none;">
        <div id="joystick-zone"><div id="joystick-knob"></div></div>
        <div id="touch-right-zone"></div>
        <div id="btn-attack">SALDIR</div>
        <div id="btn-jump"></div>
    </div>

    <div id="menu">
        <h1>BACKROOMS MCPE</h1>
        <div id="p1-slot" class="btn">OYUNCU 1: Bekleniyor...</div>
        <div id="p2-slot" class="btn" style="display:none;">OYUNCU 2: Bekleniyor...</div>
        
        <div id="controls-hint" style="margin:20px; color:#aaa; text-align:center;">
            Mod Seçimi:<br>
            <button onclick="setMode(1)" style="padding:10px;">TEK KİŞİLİK</button>
            <button onclick="setMode(2)" style="padding:10px;">ÇİFT KİŞİLİK</button>
        </div>

        <button id="btn-start" style="display:none; background:#d4d400; color:black; font-weight:bold; padding:20px 50px;" onclick="startGame()">BAŞLAT</button>
        
        <p style="font-size:12px; color:#666;">Cihazı atamak için: Klavye tuşuna bas, Gamepad'e bas veya aşağıdaki butonu kullan.</p>
        <button id="btn-touch" onclick="assignTouch()" style="background:#0055aa; color:white; padding:10px;">DOKUNMATİK KONTROLÜ SEÇ</button>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.126.0/build/three.module.js';

        // --- SİSTEM ---
        const Sys = { mode: 1, players: [], ready: 0, active: false, zombies: [] };
        const InputMap = { p1: null, p2: null };

        // --- FİZİK AYARLARI ---
        const PHYS = {
            speed: 12.5,
            gravity: 80.0,
            jumpForce: 25.0,
            lookSpeed: 0.004,
            eyeHeight: 9.0 // Göz hizası sabiti
        };

        // --- TEXTURE ---
        const tl = new THREE.TextureLoader();
        const tex = (u) => { const t = tl.load(u); t.magFilter = THREE.NearestFilter; return t; };
        const mat = {
            wall: tex('./photos/brick.png'),
            floor: tex('./photos/cobblestone.png'),
            ceil: tex('./photos/acacia_trapdoor.png')
        };

        // --- KARAKTER OLUŞTURUCU (DÜZELTİLDİ) ---
        // Model artık Y=0 (Zemin) referans alınarak oluşturuluyor.
        function createHumanoid(isZombie) {
            const group = new THREE.Group();

            const cSkin = isZombie ? 0x3d7a3d : 0xffccaa;
            const cShirt = isZombie ? 0x3d7a3d : 0x00aaaa;
            const cPants = 0x0000aa;

            const matSkin = new THREE.MeshLambertMaterial({ color: cSkin });
            const matShirt = new THREE.MeshLambertMaterial({ color: cShirt });
            const matPants = new THREE.MeshLambertMaterial({ color: cPants });

            // Bacaklar (Yükseklik: 3.5. Merkez Y: 1.75)
            const legGeo = new THREE.BoxGeometry(1.1, 3.5, 1.1);
            const rLeg = new THREE.Mesh(legGeo, matPants);
            rLeg.position.set(0.7, 1.75, 0);
            group.add(rLeg);

            const lLeg = new THREE.Mesh(legGeo, matPants);
            lLeg.position.set(-0.7, 1.75, 0);
            group.add(lLeg);

            // Gövde (Yükseklik: 3.5. Başlangıç Y: 3.5. Merkez Y: 5.25)
            const bodyGeo = new THREE.BoxGeometry(2.6, 3.5, 1.3);
            const body = new THREE.Mesh(bodyGeo, matShirt);
            body.position.y = 5.25;
            group.add(body);

            // Kollar (Merkez Y: 5.25)
            const armGeo = new THREE.BoxGeometry(1, 3.5, 1);
            const rArm = new THREE.Mesh(armGeo, isZombie ? matShirt : matSkin);
            rArm.position.set(1.9, 5.25, 0);
            if(isZombie) { rArm.rotation.x = -Math.PI/2; rArm.position.y += 1.2; rArm.position.z += 1.2; }
            group.add(rArm);

            const lArm = new THREE.Mesh(armGeo, isZombie ? matShirt : matSkin);
            lArm.position.set(-1.9, 5.25, 0);
            if(isZombie) { lArm.rotation.x = -Math.PI/2; lArm.position.y += 1.2; lArm.position.z += 1.2; }
            group.add(lArm);

            // Kafa (Yükseklik: 2.5. Başlangıç Y: 7.0. Merkez Y: 8.25)
            const headGeo = new THREE.BoxGeometry(2.5, 2.5, 2.5);
            const head = new THREE.Mesh(headGeo, matSkin);
            head.position.y = 8.25;
            group.add(head);

            return group;
        }

        // --- MENÜ ---
        window.setMode = (m) => {
            Sys.mode = m;
            if(m===2) document.getElementById('p2-slot').style.display = 'block';
            document.getElementById('controls-hint').style.display = 'none';
            checkInput();
        };
        window.assignTouch = () => assign('touch', 0);
        function checkInput() {
            if(Sys.active) return;
            const gps = navigator.getGamepads ? navigator.getGamepads() : [];
            for(let i=0; i<gps.length; i++) if(gps[i] && gps[i].buttons.some(b=>b.pressed)) assign('gamepad', i);
            requestAnimationFrame(checkInput);
        }
        window.addEventListener('keydown', e => {
            if(['KeyW','ArrowUp'].includes(e.code)) assign('keyboard', 0);
        });
        function assign(type, idx) {
            if(Sys.ready >= Sys.mode) return;
            if((InputMap.p1?.type===type && InputMap.p1.index===idx) || (InputMap.p2?.type===type && InputMap.p2.index===idx)) return;
            const pid = InputMap.p1 ? 2 : 1;
            InputMap['p'+pid] = { type, index: idx };
            const slot = document.getElementById('p'+pid+'-slot');
            slot.innerText = `OYUNCU ${pid}: ${type.toUpperCase()}`;
            slot.classList.add('active-slot');
            if(type==='touch') document.getElementById('btn-touch').style.display='none';
            Sys.ready++;
            if(Sys.ready === Sys.mode) document.getElementById('btn-start').style.display='block';
        }

        // --- TOUCH ---
        const TouchData = { moveX: 0, moveZ: 0, lookX: 0, lookY: 0, jump: false, attack: false, joyID: null, lookID: null };
        function initTouch() {
            const ui = document.getElementById('touch-ui');
            const joyZone = document.getElementById('joystick-zone');
            const joyKnob = document.getElementById('joystick-knob');
            const lookZone = document.getElementById('touch-right-zone');
            const jumpBtn = document.getElementById('btn-jump');
            const attackBtn = document.getElementById('btn-attack');

            ui.style.display = 'block';
            if(Sys.mode === 2) {
                const p1Touch = InputMap.p1?.type === 'touch';
                ui.style.left = p1Touch ? '0' : '50%';
                ui.style.width = '50%';
            }

            let joyStart = {x:0, y:0};
            joyZone.addEventListener('touchstart', e => {
                e.preventDefault();
                const t = e.changedTouches[0];
                TouchData.joyID = t.identifier;
                joyStart.x = t.clientX; joyStart.y = t.clientY;
            });
            joyZone.addEventListener('touchmove', e => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if(t.identifier === TouchData.joyID) {
                        let dx = t.clientX - joyStart.x;
                        let dy = t.clientY - joyStart.y;
                        const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 50);
                        const angle = Math.atan2(dy, dx);
                        const jx = Math.cos(angle) * dist;
                        const jy = Math.sin(angle) * dist;
                        joyKnob.style.transform = `translate(calc(-50% + ${jx}px), calc(-50% + ${jy}px))`;
                        TouchData.moveX = jx / 50; TouchData.moveZ = jy / 50;
                    }
                }
            });
            joyZone.addEventListener('touchend', e => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === TouchData.joyID) {
                        TouchData.joyID = null;
                        TouchData.moveX = 0; TouchData.moveZ = 0;
                        joyKnob.style.transform = `translate(-50%, -50%)`;
                    }
                }
            });

            let lookStart = {x:0, y:0};
            lookZone.addEventListener('touchstart', e => {
                e.preventDefault();
                if(e.target !== jumpBtn && e.target !== attackBtn) {
                    const t = e.changedTouches[0];
                    TouchData.lookID = t.identifier;
                    lookStart.x = t.clientX; lookStart.y = t.clientY;
                }
            });
            lookZone.addEventListener('touchmove', e => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if(t.identifier === TouchData.lookID) {
                        TouchData.lookX = (t.clientX - lookStart.x);
                        TouchData.lookY = (t.clientY - lookStart.y);
                        lookStart.x = t.clientX; lookStart.y = t.clientY;
                    }
                }
            });
            lookZone.addEventListener('touchend', e => {
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === TouchData.lookID) TouchData.lookID = null;
                }
            });

            jumpBtn.addEventListener('touchstart', e => { e.preventDefault(); TouchData.jump = true; });
            jumpBtn.addEventListener('touchend', e => { e.preventDefault(); TouchData.jump = false; });
            attackBtn.addEventListener('touchstart', e => { e.preventDefault(); TouchData.attack = true; });
            attackBtn.addEventListener('touchend', e => { e.preventDefault(); TouchData.attack = false; });
        }

        window.startGame = () => {
            document.getElementById('menu').style.display = 'none';
            if(document.documentElement.requestFullscreen) document.documentElement.requestFullscreen().catch(()=>{});
            if(InputMap.p1?.type==='touch' || InputMap.p2?.type==='touch') initTouch();
            if(InputMap.p1?.type==='keyboard' || InputMap.p2?.type==='keyboard') document.body.requestPointerLock();
            initEngine();
        };

        // --- ENGINE ---
        let scene, renderer, clock;
        const map = [], WS = 40, BS = 5;
        const keys = {};

        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if(e.code === 'KeyF') attackZombie(0);
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        function initEngine() {
            Sys.active = true;
            clock = new THREE.Clock();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 0, 25);
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));

            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClear = false;
            document.body.appendChild(renderer.domElement);

            generateWorld();
            
            if(InputMap.p1) createPlayer(1, InputMap.p1);
            if(InputMap.p2) { createPlayer(2, InputMap.p2); document.getElementById('split-line').style.display='block'; }

            setInterval(trySpawnZombie, 1000); 

            animate();
        }

        function generateWorld() {
            const geo = new THREE.BoxGeometry(BS, BS*3, BS);
            const pln = new THREE.PlaneGeometry(BS, BS);
            const mW = new THREE.MeshLambertMaterial({ map: mat.wall });
            const mF = new THREE.MeshLambertMaterial({ map: mat.floor });
            const mC = new THREE.MeshLambertMaterial({ map: mat.ceil });

            for(let x=0; x<WS; x++) {
                map[x] = [];
                for(let z=0; z<WS; z++) {
                    const px = (x-WS/2)*BS, pz = (z-WS/2)*BS;
                    const f = new THREE.Mesh(pln, mF); f.rotation.x = -Math.PI/2; f.position.set(px,0,pz); scene.add(f);
                    const c = new THREE.Mesh(pln, mC); c.rotation.x = Math.PI/2; c.position.set(px,BS*3,pz); scene.add(c);
                    let w = (x===0||x===WS-1||z===0||z===WS-1) || (Math.random()<0.1 && Math.abs(x-WS/2)>2);
                    if(w) {
                        map[x][z] = 1;
                        const b = new THREE.Mesh(geo, mW); b.position.set(px,BS*1.5,pz); scene.add(b);
                    } else map[x][z] = 0;
                }
            }
        }

        function createPlayer(id, inp) {
            const o = new THREE.Object3D();
            const c = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
            o.add(c);
            
            // STEVE MODELİ
            const steve = createHumanoid(false);
            // DÜZELTME: Kamera Y=9'da olduğu için, modelin ayaklarının yere basması için
            // modeli kameraya göre 9 birim aşağı kaydırıyoruz.
            steve.position.y = -PHYS.eyeHeight;
            o.add(steve);

            const l = new THREE.SpotLight(0xffaa00, 1, 25, 0.6); l.position.set(0,PHYS.eyeHeight,0); l.target.position.set(0,PHYS.eyeHeight,-1);
            o.add(l); o.add(l.target);
            
            o.position.set(id===1?-5:5, PHYS.eyeHeight, 0);
            scene.add(o);

            Sys.players.push({
                id, obj: o, cam: c, inp, rotX: 0, 
                vel: new THREE.Vector3(0,0,0), onGround: false
            });
        }

        // --- ZOMBİ MANTIĞI ---
        function trySpawnZombie() {
            if(Sys.zombies.length >= 5) return;
            if(Math.random() > 0.3) return;

            const rx = Math.floor(Math.random() * WS);
            const rz = Math.floor(Math.random() * WS);
            
            if(map[rx][rz] === 0) {
                const px = (rx-WS/2)*BS;
                const pz = (rz-WS/2)*BS;
                
                let tooClose = false;
                Sys.players.forEach(p => {
                    if(p.obj.position.distanceTo(new THREE.Vector3(px, PHYS.eyeHeight, pz)) < 20) tooClose = true;
                });
                if(tooClose) return;

                const zObj = new THREE.Object3D();
                // DÜZELTME: Zombiler zeminde (Y=0) doğar.
                zObj.position.set(px, 0, pz);
                const zModel = createHumanoid(true);
                zObj.add(zModel);
                scene.add(zObj);

                Sys.zombies.push({ obj: zObj, hp: 3 });
            }
        }

        function attackZombie(playerIdx) {
            if(!Sys.players[playerIdx]) return;
            const p = Sys.players[playerIdx];
            
            for(let i=0; i<Sys.zombies.length; i++) {
                const z = Sys.zombies[i];
                // Mesafe kontrolü (Zombinin ayaklarına olan mesafe)
                if(z.obj.position.distanceTo(new THREE.Vector3(p.obj.position.x, 0, p.obj.position.z)) < 8) {
                    z.hp--;
                    z.obj.children[0].children[0].material.color.setHex(0xff0000); // Kızar
                    setTimeout(() => {
                        if(z.obj && z.obj.children[0]) z.obj.children[0].children[0].material.color.setHex(0x3d7a3d);
                    }, 200);

                    if(z.hp <= 0) {
                        scene.remove(z.obj);
                        Sys.zombies.splice(i, 1);
                    }
                    break;
                }
            }
        }

        let mx=0, my=0;
        document.addEventListener('mousemove', e => { if(document.pointerLockElement) { mx+=e.movementX; my+=e.movementY; } });

        function checkCol(pos) {
            const gx = Math.round(pos.x/BS + WS/2);
            const gz = Math.round(pos.z/BS + WS/2);
            if(gx<0||gx>=WS||gz<0||gz>=WS) return true;
            return map[gx][gz] === 1;
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);

            // --- OYUNCULAR ---
            Sys.players.forEach(p => {
                let inputX = 0, inputZ = 0, inputJump = false, rotY = 0, rotX = 0;

                if(p.inp.type === 'keyboard') {
                    if(keys['KeyW']) inputZ = -1; if(keys['KeyS']) inputZ = 1;
                    if(keys['KeyA']) inputX = -1; if(keys['KeyD']) inputX = 1;
                    if(keys['Space']) inputJump = true;
                    rotY = -mx * 0.002; rotX = -my * 0.002;
                }
                else if(p.inp.type === 'touch') {
                    inputX = TouchData.moveX; inputZ = TouchData.moveZ;
                    inputJump = TouchData.jump;
                    rotY = -TouchData.lookX * PHYS.lookSpeed; rotX = -TouchData.lookY * PHYS.lookSpeed;
                    
                    if(TouchData.attack) {
                        attackZombie(p.id-1);
                        TouchData.attack = false;
                    }
                    TouchData.lookX = 0; TouchData.lookY = 0;
                }
                else if(p.inp.type === 'gamepad') {
                    const gp = navigator.getGamepads()[p.inp.index];
                    if(gp) {
                        if(Math.abs(gp.axes[0])>0.1) inputX = gp.axes[0];
                        if(Math.abs(gp.axes[1])>0.1) inputZ = gp.axes[1];
                        if(gp.buttons[0].pressed) inputJump = true;
                        if(gp.buttons[2].pressed || gp.buttons[5].pressed || gp.buttons[7].pressed) attackZombie(p.id-1);
                        if(Math.abs(gp.axes[2])>0.1) rotY = -gp.axes[2]*0.04;
                        if(Math.abs(gp.axes[3])>0.1) rotX = -gp.axes[3]*0.04;
                    }
                }

                p.obj.rotation.y += rotY;
                p.rotX = Math.max(-1.5, Math.min(1.5, p.rotX + rotX));
                p.cam.rotation.x = p.rotX;

                const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(p.obj.quaternion); forward.y = 0; forward.normalize();
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(p.obj.quaternion); right.y = 0; right.normalize();
                const moveDir = new THREE.Vector3();
                moveDir.addScaledVector(forward, inputZ); moveDir.addScaledVector(right, inputX);
                if(moveDir.length() > 1) moveDir.normalize();

                p.vel.x = moveDir.x * PHYS.speed;
                p.vel.z = moveDir.z * PHYS.speed;

                if(p.onGround) {
                    if(inputJump) { p.vel.y = PHYS.jumpForce; p.onGround = false; } else p.vel.y = 0;
                } else {
                    p.vel.y -= PHYS.gravity * dt;
                }

                p.obj.position.x += p.vel.x * dt;
                if(checkCol(p.obj.position)) p.obj.position.x -= p.vel.x * dt;

                p.obj.position.z += p.vel.z * dt;
                if(checkCol(p.obj.position)) p.obj.position.z -= p.vel.z * dt;

                p.obj.position.y += p.vel.y * dt;
                
                if(p.obj.position.y < PHYS.eyeHeight) { p.obj.position.y = PHYS.eyeHeight; p.onGround = true; p.vel.y = 0; } 
                else { p.onGround = false; }
            });

            // --- ZOMBİLERİ HAREKET ETTİR ---
            const zSpeed = 4.0;
            Sys.zombies.forEach(z => {
                let closestDist = 999;
                let target = null;
                Sys.players.forEach(p => {
                    const d = p.obj.position.distanceTo(z.obj.position);
                    if(d < closestDist) { closestDist = d; target = p; }
                });

                if(target && closestDist < 60) {
                    // DÜZELTME: Zombiler yukarı bakmasın, düz baksın (Y=0 hedefle)
                    z.obj.lookAt(target.obj.position.x, 0, target.obj.position.z);
                    const fwd = new THREE.Vector3(0,0,1).applyQuaternion(z.obj.quaternion);
                    
                    z.obj.position.addScaledVector(fwd, zSpeed * dt);
                    if(checkCol(z.obj.position)) z.obj.position.addScaledVector(fwd, -zSpeed * dt);
                }
            });

            if(InputMap.p1?.type==='keyboard') { mx=0; my=0; }

            const w=window.innerWidth, h=window.innerHeight;
            if(Sys.players.length===1) {
                const p = Sys.players[0]; p.cam.aspect=w/h; p.cam.updateProjectionMatrix();
                renderer.setViewport(0,0,w,h); renderer.setScissor(0,0,w,h); renderer.setScissorTest(true);
                renderer.render(scene, p.cam);
            } else {
                Sys.players.forEach((p,i)=>{
                    const l=i===0?0:w/2;
                    p.cam.aspect=(w/2)/h; p.cam.updateProjectionMatrix();
                    renderer.setViewport(l,0,w/2,h); renderer.setScissor(l,0,w/2,h); renderer.setScissorTest(true);
                    renderer.render(scene, p.cam);
                });
            }
        }
        window.addEventListener('resize', ()=>renderer.setSize(window.innerWidth, window.innerHeight));
    </script>
</body>
</html>
