<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Backrooms: Music & Hit Sounds</title>
    <style>
        /* --- GENEL AYARLAR --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        /* --- ARAYÜZ (UI) --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* CAN BARI */
        #health-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 250px;
            height: 25px;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid white;
            border-radius: 12px;
            overflow: hidden;
            display: block;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        #health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff4444);
            transition: width 0.2s ease-out;
        }

        /* HASAR EFEKTİ */
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: red;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s ease-in-out;
            z-index: 5;
        }

        /* BİLGİ MESAJI */
        #join-alert {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            color: #00ff00;
            font-size: 30px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            display: none;
            z-index: 150;
        }

        /* MENÜLER */
        .overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 100;
            pointer-events: auto;
        }

        .overlay-screen h1 {
            font-size: 60px;
            margin: 0 0 20px 0;
            text-shadow: 4px 4px 0px #000;
        }

        .overlay-screen p {
            font-size: 24px;
            color: #ccc;
            margin-top: 10px;
            animation: blink 1.5s infinite;
        }

        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0.4; }
            100% { opacity: 1; }
        }

        #pause-screen h1 { color: #ffff00; }
        #game-over-screen h1 { color: #ff0000; }

        /* DOKUNMATİK KONTROLLER */
        #touch-ui { display: none; }

        #joystick-zone {
            position: absolute; bottom: 50px; left: 50px; width: 160px; height: 160px;
            background: rgba(255, 255, 255, 0.05); border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%; pointer-events: auto; touch-action: none;
        }

        #joystick-knob {
            position: absolute; top: 50%; left: 50%; width: 70px; height: 70px;
            background: rgba(255, 200, 0, 0.5); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            box-shadow: 0 0 15px rgba(255, 200, 0, 0.3);
        }

        #touch-right-zone {
            position: absolute; top: 0; right: 0; width: 50%; height: 100%;
            pointer-events: auto; z-index: 20; touch-action: none;
        }

        #btn-jump {
            position: absolute; bottom: 80px; right: 40px; width: 100px; height: 100px;
            border-radius: 50%; background: rgba(200, 200, 200, 0.2);
            border: 3px solid rgba(255, 255, 255, 0.3); pointer-events: auto; z-index: 30;
            display: flex; align-items: center; justify-content: center;
            color: white; font-weight: bold; font-size: 16px; user-select: none;
        }

        #btn-attack {
            position: absolute; bottom: 80px; right: 160px; width: 80px; height: 80px;
            border-radius: 50%; background: rgba(255, 0, 0, 0.5);
            border: 3px solid rgba(255, 100, 100, 0.7); pointer-events: auto; z-index: 30;
            display: flex; align-items: center; justify-content: center;
            color: white; font-weight: bold; font-size: 14px; user-select: none;
            box-shadow: 0 0 10px rgba(255,0,0,0.3);
        }
        #btn-attack:active { background: rgba(255, 0, 0, 0.8); transform: scale(0.95); }

        /* MENÜ */
        #menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; color: #ffea00; z-index: 1000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        #menu h1 { font-family: 'Courier New', monospace; font-size: 50px; margin-bottom: 30px; text-shadow: 3px 3px 5px #000; }
        .btn {
            padding: 25px 50px; font-size: 24px; background: #333; color: white;
            border: 3px solid #555; margin: 15px; border-radius: 15px;
            cursor: pointer; width: 80%; max-width: 350px; text-align: center; transition: background 0.2s;
        }
        .btn:hover { background: #444; }
        .active-slot { border-color: #0f0; background: #003300; color: #0f0; }
        #split-line { position: absolute; left: 50%; top: 0; width: 4px; height: 100%; background: #000; display: none; z-index: 5; transform: translateX(-50%); }
    </style>
</head>
<body>

    <div id="damage-overlay"></div>
    <div id="split-line"></div>
    <div id="join-alert">2. OYUNCU KATILDI!</div>

    <div id="ui-layer"><div id="health-container"><div id="health-bar"></div></div></div>

    <div id="pause-screen" class="overlay-screen"><h1>DURAKLATILDI</h1><p>Devam etmek için Start'a bas</p></div>
    <div id="game-over-screen" class="overlay-screen"><h1>ÖLDÜN!</h1><p>Yeniden doğmak için dokun</p></div>

    <div id="touch-ui">
        <div id="joystick-zone"><div id="joystick-knob"></div></div>
        <div id="touch-right-zone"></div>
        <div id="btn-attack">VUR</div>
        <div id="btn-jump">ZIPLA</div>
    </div>

    <div id="menu">
        <h1>THE BACKROOMS</h1>
        <div id="p1-slot" class="btn">OYUNCU 1: Bekleniyor...</div>
        <div id="p2-slot" class="btn" style="display:none;">OYUNCU 2: Bekleniyor...</div>
        <div id="controls-hint" style="margin:20px; color:#aaa; text-align:center;">
            <button onclick="setMode(1)" style="padding:10px; margin:5px; font-size:16px;">TEK KİŞİLİK</button>
            <button onclick="setMode(2)" style="padding:10px; margin:5px; font-size:16px;">ÇİFT KİŞİLİK</button>
        </div>
        <button id="btn-start" style="display:none; background:#d4d400; color:black; font-weight:bold; padding:25px 60px;" onclick="startGame()">BAŞLAT</button>
        <p style="font-size:14px; color:#888; margin-top: 20px;">Müzik ve efektler için 'sounds' klasörünü kontrol edin.</p>
        <button id="btn-touch" onclick="assignTouch()" style="background:#0055aa; color:white; padding:15px; font-size:14px; margin-top:10px;">DOKUNMATİK SEÇ</button>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.126.0/build/three.module.js';

        // ==========================================
        // 1. SİSTEM DEĞİŞKENLERİ
        // ==========================================
        const Sys = { mode: 1, players: [], ready: 0, active: false, paused: false, isGameOver: false, zombies: [] };
        const InputMap = { p1: null, p2: null };
        const P2JoinData = { lastPressTime: 0, presses: 0 };
        const PauseData = { lastState: false };
        const PHYS = { speed: 12.5, gravity: 80.0, jumpForce: 25.0, lookSpeed: 0.012 };
        const WS = 100, BS = 5;
        let map = [], mapTypes = [];

        // ==========================================
        // 2. SES & MÜZİK SİSTEMİ
        // ==========================================
        const Sounds = {};
        // Efektler
        const fxFiles = {
            step: './sounds/step.mp3',
            jump: './sounds/jump.mp3',
            attack: './sounds/attack.mp3',
            hurt: './sounds/hurt.mp3',
            zombie: './sounds/zombie.mp3'
        };
        // Müzikler (Rastgele Çalacak)
        const musicFiles = [
            './sounds/LivingMice.mp3',
            './sounds/MoogCity.mp3',
            './sounds/SubwooferLullaby.mp3'
        ];
        let currentMusic = null;

        function loadSounds() {
            // Efektleri Yükle
            for (const [key, path] of Object.entries(fxFiles)) {
                const audio = new Audio(path);
                audio.volume = 0.4;
                Sounds[key] = audio;
            }
            if(Sounds.step) Sounds.step.volume = 0.2;
            if(Sounds.zombie) Sounds.zombie.volume = 0.6;
        }

        function playSound(name) {
            if (Sounds[name] && Sys.active && !Sys.paused) {
                Sounds[name].pause();
                Sounds[name].currentTime = 0;
                Sounds[name].play().catch(()=>{});
            }
        }

        function playRandomMusic() {
            if(currentMusic) return; // Zaten çalıyor
            
            const randomTrack = musicFiles[Math.floor(Math.random() * musicFiles.length)];
            currentMusic = new Audio(randomTrack);
            currentMusic.volume = 0.3; // Arkaplan müziği seviyesi
            
            currentMusic.play().then(() => {
                console.log("Müzik başladı: " + randomTrack);
            }).catch(e => console.log("Müzik hatası (Etkileşim gerek):", e));

            // Müzik bitince
            currentMusic.onended = () => {
                currentMusic = null;
                // Bir sonraki şarkı için rastgele süre bekle (30sn - 2dk arası)
                const waitTime = Math.random() * 90000 + 30000;
                setTimeout(playRandomMusic, waitTime);
            };
        }

        // ==========================================
        // 3. DOKULAR
        // ==========================================
        const tl = new THREE.TextureLoader();
        function loadTex(path, repeatY) {
            const t = tl.load(path);
            t.magFilter = THREE.NearestFilter; t.minFilter = THREE.NearestFilter;
            t.wrapS = THREE.RepeatWrapping; t.wrapT = THREE.RepeatWrapping;
            if (repeatY > 1) t.repeat.set(1, repeatY);
            return t;
        }

        const texMain = {
            base: loadTex('./photos/hardened_clay_stained_magenta.png', 7),
            glass: loadTex('./photos/glass_orange.png', 7),
            var1: loadTex('./photos/hardened_clay_stained_magenta_1.png', 7),
            var2: loadTex('./photos/hardened_clay_stained_magenta_2.png', 7),
            pink: loadTex('./photos/hardened_clay_stained_pink.png', 7),
            pink1: loadTex('./photos/hardened_clay_stained_pink_1.png', 7)
        };
        const texRare = {
            acacia: loadTex('./photos/acacia_trapdoor.png', 7),
            brick: loadTex('./photos/brick.png', 7),
            cobble: loadTex('./photos/cobblestone.png', 7),
            mossy: loadTex('./photos/cobblestone_mossy.png', 7)
        };
        const texFloor = {
            main: loadTex('./photos/hardened_clay_stained_magenta.png', 1),
            deepslate: loadTex('./photos/cracked_deepslate_bricks.png', 1),
            ceil: loadTex('./photos/acacia_trapdoor.png', 1)
        };

        // MATERYALLER
        const matList = {
            mainBase: new THREE.MeshLambertMaterial({ map: texMain.base }),
            mainGlass: new THREE.MeshLambertMaterial({ map: texMain.glass, transparent: true, opacity: 0.9 }),
            mainVar1: new THREE.MeshLambertMaterial({ map: texMain.var1 }),
            mainVar2: new THREE.MeshLambertMaterial({ map: texMain.var2 }),
            mainPink: new THREE.MeshLambertMaterial({ map: texMain.pink }),
            mainPink1: new THREE.MeshLambertMaterial({ map: texMain.pink1 }),
            rareAcacia: new THREE.MeshLambertMaterial({ map: texRare.acacia }),
            rareBrick: new THREE.MeshLambertMaterial({ map: texRare.brick }),
            rareCobble: new THREE.MeshLambertMaterial({ map: texRare.cobble }),
            rareMossy: new THREE.MeshLambertMaterial({ map: texRare.mossy }),
            floorMain: new THREE.MeshLambertMaterial({ map: texFloor.main }),
            floorRare: new THREE.MeshLambertMaterial({ map: texFloor.deepslate }),
            ceil: new THREE.MeshLambertMaterial({ map: texFloor.ceil })
        };
        const wallsMain = [matList.mainBase, matList.mainBase, matList.mainBase, matList.mainGlass, matList.mainVar1, matList.mainVar2, matList.mainPink, matList.mainPink1];
        const wallsRare = [matList.rareAcacia, matList.rareBrick, matList.rareCobble, matList.rareMossy];

        // ==========================================
        // 4. KARAKTER & ZOMBİ MODELİ (GÖZLÜ/AĞIZLI)
        // ==========================================
        function createHumanoid(isZombie) {
            const group = new THREE.Group();
            const cSkin = isZombie ? 0x4a6b4a : 0xffccaa; 
            const cShirt = isZombie ? 0x3d5c5c : 0x00aaaa; 
            const cPants = isZombie ? 0x2a2a5c : 0x0000aa;
            const cEyeW = isZombie ? 0x111111 : 0xffffff;
            const cEyeP = isZombie ? 0x000000 : 0x0000ff;
            const cMouth = isZombie ? 0x220000 : 0x663333;

            const matSkin = new THREE.MeshLambertMaterial({ color: cSkin });
            const matShirt = new THREE.MeshLambertMaterial({ color: cShirt });
            const matPants = new THREE.MeshLambertMaterial({ color: cPants });
            const matEyeW = new THREE.MeshLambertMaterial({ color: cEyeW });
            const matPupil = new THREE.MeshLambertMaterial({ color: cEyeP });
            const matMouth = new THREE.MeshLambertMaterial({ color: cMouth });

            const head = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2.5, 2.5), matSkin);
            head.position.y = 8.25; 
            
            const eyeGeo = new THREE.BoxGeometry(0.6, 0.6, 0.1);
            const pupilGeo = new THREE.BoxGeometry(0.3, 0.3, 0.11);
            const lEye = new THREE.Mesh(eyeGeo, matEyeW); lEye.position.set(-0.7, 0.3, 1.26);
            const lPupil = new THREE.Mesh(pupilGeo, matPupil); lPupil.position.set(0, 0, 0.05); lEye.add(lPupil);
            head.add(lEye);
            const rEye = new THREE.Mesh(eyeGeo, matEyeW); rEye.position.set(0.7, 0.3, 1.26);
            const rPupil = new THREE.Mesh(pupilGeo, matPupil); rPupil.position.set(0, 0, 0.05); rEye.add(rPupil);
            head.add(rEye);
            const mouth = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.4, 0.1), matMouth);
            mouth.position.set(0, -0.6, 1.26); head.add(mouth);
            group.add(head);

            const body = new THREE.Mesh(new THREE.BoxGeometry(2.6, 3.5, 1.3), matShirt);
            body.position.y = 5.25; group.add(body);
            
            const armGeo = new THREE.BoxGeometry(1, 3.5, 1);
            const rArm = new THREE.Mesh(armGeo, isZombie ? matShirt : matSkin);
            rArm.position.set(1.9, 5.25, 0); 
            if(isZombie) { rArm.rotation.x = -Math.PI/2; rArm.position.y += 1; rArm.position.z += 1.5; }
            group.add(rArm);
            const lArm = new THREE.Mesh(armGeo, isZombie ? matShirt : matSkin);
            lArm.position.set(-1.9, 5.25, 0); 
            if(isZombie) { lArm.rotation.x = -Math.PI/2; lArm.position.y += 1; lArm.position.z += 1.5; }
            group.add(lArm);

            const legGeo = new THREE.BoxGeometry(1.1, 3.5, 1.1);
            const rLeg = new THREE.Mesh(legGeo, matPants); rLeg.position.set(0.7, 1.75, 0); group.add(rLeg);
            const lLeg = new THREE.Mesh(legGeo, matPants); lLeg.position.set(-0.7, 1.75, 0); group.add(lLeg);
            return group;
        }

        // ==========================================
        // 5. MENÜ & GİRİŞ
        // ==========================================
        window.setMode = (m) => { Sys.mode = m; if(m===2) document.getElementById('p2-slot').style.display = 'block'; document.getElementById('controls-hint').style.display = 'none'; checkInput(); };
        window.assignTouch = () => assign('touch', 0);
        function checkInput() { if(Sys.active) return; const gps = navigator.getGamepads ? navigator.getGamepads() : []; for(let i=0; i<gps.length; i++) { if(gps[i] && gps[i].buttons.some(b=>b.pressed)) assign('gamepad', i); } requestAnimationFrame(checkInput); }
        const keys = {}; window.addEventListener('keydown', e => { keys[e.code] = true; if(!Sys.active && ['KeyW','ArrowUp'].includes(e.code)) assign('keyboard', 0); if(Sys.active && e.code === 'KeyF') attack(0); if(Sys.isGameOver) resetGame(); }); window.addEventListener('keyup', e => keys[e.code] = false);
        document.getElementById('game-over-screen').addEventListener('click', resetGame); document.getElementById('game-over-screen').addEventListener('touchstart', resetGame);
        function assign(type, idx) {
            if(Sys.ready >= Sys.mode) return; if(InputMap.p1 && InputMap.p1.type === type && InputMap.p1.index === idx) return;
            const pid = InputMap.p1 ? 2 : 1; InputMap['p'+pid] = { type, index: idx };
            document.getElementById('p'+pid+'-slot').innerText = `OYUNCU ${pid}: ${type.toUpperCase()}`;
            document.getElementById('p'+pid+'-slot').classList.add('active-slot');
            if(type==='touch') document.getElementById('btn-touch').style.display='none';
            Sys.ready++; if(Sys.ready === Sys.mode) document.getElementById('btn-start').style.display='block';
        }

        // ==========================================
        // 6. OYUN BAŞLATMA
        // ==========================================
        window.startGame = () => {
            document.getElementById('menu').style.display = 'none';
            if(document.documentElement.requestFullscreen) document.documentElement.requestFullscreen().catch(()=>{});
            if(InputMap.p1?.type==='touch' || InputMap.p2?.type==='touch') initTouch();
            if(InputMap.p1?.type==='keyboard' || InputMap.p2?.type==='keyboard') document.body.requestPointerLock();
            initEngine();
        };

        let scene, renderer, clock;
        function initEngine() {
            Sys.active = true; clock = new THREE.Clock(); scene = new THREE.Scene();
            scene.background = new THREE.Color(0x503050); scene.fog = new THREE.FogExp2(0x503050, 0.035);
            const light = new THREE.AmbientLight(0xffffff, 0.95); scene.add(light);
            renderer = new THREE.WebGLRenderer({ antialias: false }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.autoClear = false; document.body.appendChild(renderer.domElement);
            
            loadSounds(); // Sesleri yükle
            generateWorld();
            if(InputMap.p1) createPlayer(1, InputMap.p1);
            if(InputMap.p2) { createPlayer(2, InputMap.p2); document.getElementById('split-line').style.display='block'; }
            
            // ZOMBI SİSTEMİ AKTİF
            setInterval(trySpawnZombies, 10000);
            
            // Müzik Başlat
            setTimeout(playRandomMusic, 2000); // 2 saniye sonra müzik başlasın

            animate();
        }

        // ==========================================
        // 7. DÜNYA
        // ==========================================
        function generateWorld() {
            const geo = new THREE.BoxGeometry(BS, BS*7, BS); const pln = new THREE.PlaneGeometry(BS, BS);
            for(let x=0; x<WS; x++) { mapTypes[x] = []; map[x] = []; for(let z=0; z<WS; z++) mapTypes[x][z] = 0; }
            for(let i=0; i<3; i++) { const rx = Math.floor(Math.random()*(WS-10))+5; const rz = Math.floor(Math.random()*(WS-10))+5; for(let x=rx-2; x<=rx+2; x++) for(let z=rz-2; z<=rz+2; z++) mapTypes[x][z] = 1; }
            for(let x=0; x<WS; x++) {
                for(let z=0; z<WS; z++) {
                    const px = (x-WS/2)*BS, pz = (z-WS/2)*BS; const isRare = (mapTypes[x][z] === 1);
                    const floorMat = isRare ? matList.floorRare : matList.floorMain;
                    const f = new THREE.Mesh(pln, floorMat); f.rotation.x = -Math.PI/2; f.position.set(px,0,pz); scene.add(f);
                    const c = new THREE.Mesh(pln, matList.ceil); c.rotation.x = Math.PI/2; c.position.set(px,BS*7,pz); scene.add(c);
                    let w = (x===0||x===WS-1||z===0||z===WS-1) || (Math.random()<0.1 && Math.abs(x-WS/2)>2 && Math.abs(z-WS/2)>2);
                    if(w) {
                        map[x][z] = 1; let wallMat;
                        if(isRare) wallMat = wallsRare[Math.floor(Math.random() * wallsRare.length)];
                        else { const rnd = Math.random(); if(rnd < 0.10) wallMat = matList.mainGlass; else if(rnd < 0.30) wallMat = wallsMain[Math.floor(Math.random() * wallsMain.length)]; else wallMat = matList.mainBase; }
                        const b = new THREE.Mesh(geo, wallMat); b.position.set(px,BS*3.5,pz); scene.add(b);
                    } else map[x][z] = 0;
                }
            }
        }

        function createPlayer(id, inp) {
            const o = new THREE.Object3D(); const c = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100); o.add(c);
            const steve = createHumanoid(false); steve.position.y = -9.0; o.add(steve);
            const l = new THREE.PointLight(0xffaa00, 0.3, 15); l.position.set(0,0,0); o.add(l);
            o.position.set(id===1?-5:5, 9, 0); scene.add(o);
            Sys.players.push({ id, obj: o, cam: c, inp, rotX: 0, vel: new THREE.Vector3(0,0,0), onGround: false, hp: 100, model: steve, lastStepTime: 0 });
        }

        // ==========================================
        // 8. SALDIRI VE ZOMBİLER
        // ==========================================
        function trySpawnZombies() {
            if(Sys.isGameOver || Sys.paused || Sys.zombies.length >= 15) return;
            let spawned = 0, attempts = 0;
            while(spawned < 3 && attempts < 50) {
                attempts++; const rx = Math.floor(Math.random() * WS), rz = Math.floor(Math.random() * WS);
                if(map[rx][rz] === 0) {
                    const px = (rx-WS/2)*BS, pz = (rz-WS/2)*BS;
                    let tooClose = false; Sys.players.forEach(p => { if(p.obj.position.distanceTo(new THREE.Vector3(px, 9, pz)) < 20) tooClose = true; });
                    if(!tooClose) {
                        const zObj = new THREE.Object3D();
                        const zModel = createHumanoid(true); zModel.position.y = -9.0; zObj.add(zModel); zObj.position.set(px, 9, pz);
                        scene.add(zObj); Sys.zombies.push({ obj: zObj, hp: 3 }); spawned++; playSound('zombie');
                    }
                }
            }
        }

        // SALDIRI FONKSİYONU (PvP ve PvE)
        function attack(attackerIdx) {
            if(!Sys.players[attackerIdx] || Sys.isGameOver || Sys.paused) return;
            const attacker = Sys.players[attackerIdx];
            attacker.cam.position.y -= 0.2; setTimeout(()=>attacker.cam.position.y += 0.2, 50);
            
            // Eğer vuruş isabet ederse ses çıkacak, boş sallayınca ses yok (istek üzerine)
            let hitConfirmed = false; 

            // Zombilere Saldırı
            for(let i=0; i<Sys.zombies.length; i++) {
                const z = Sys.zombies[i];
                if(z.obj.position.distanceTo(attacker.obj.position) < 25) {
                    z.hp--; hitConfirmed = true;
                    playSound('attack'); // Vuruş sesi (hit sound)
                    z.obj.children[0].children.forEach(mesh => { if(mesh.material?.emissive) mesh.material.emissive.setHex(0xff0000); });
                    setTimeout(() => { if(z.obj) z.obj.children[0].children.forEach(mesh => { if(mesh.material?.emissive) mesh.material.emissive.setHex(0x000000); }); }, 200);
                    const knock = new THREE.Vector3().subVectors(z.obj.position, attacker.obj.position).normalize().multiplyScalar(4); z.obj.position.add(knock);
                    if(z.hp <= 0) { scene.remove(z.obj); Sys.zombies.splice(i, 1); } break;
                }
            }

            // Oyunculara Saldırı (PvP)
            if(!hitConfirmed && Sys.mode === 2) {
                Sys.players.forEach((target, idx) => {
                    if(idx !== attackerIdx && target.obj.position.distanceTo(attacker.obj.position) < 25) {
                        target.hp -= 10; hitConfirmed = true;
                        playSound('attack'); playSound('hurt'); // Hem vuruş hem acı sesi
                        if(target.id === 1) { const ov = document.getElementById('damage-overlay'); ov.style.opacity = 0.5; setTimeout(()=>ov.style.opacity=0, 100); }
                        const knock = new THREE.Vector3().subVectors(target.obj.position, attacker.obj.position).normalize().multiplyScalar(6); target.obj.position.add(knock);
                    }
                });
            }
        }

        // ==========================================
        // 9. SİSTEM YÖNETİMİ
        // ==========================================
        function resetGame() { if(!Sys.isGameOver) return; Sys.isGameOver = false; Sys.players.forEach(p => { p.hp = 100; p.obj.position.set(p.id===1?-5:5, 9, 0); }); document.getElementById('health-bar').style.width = '100%'; Sys.zombies.forEach(z => scene.remove(z.obj)); Sys.zombies = []; document.getElementById('game-over-screen').style.display = 'none'; if(InputMap.p1 && InputMap.p1.type==='keyboard') document.body.requestPointerLock(); }
        function joinPlayer2(gpIndex) { if(Sys.mode === 2) return; Sys.mode = 2; InputMap.p2 = { type: 'gamepad', index: gpIndex }; createPlayer(2, InputMap.p2); document.getElementById('split-line').style.display = 'block'; document.getElementById('join-alert').style.display = 'block'; setTimeout(()=>document.getElementById('join-alert').style.display='none', 3000); if(InputMap.p1.type === 'touch') { document.getElementById('touch-ui').style.width = '50%'; document.getElementById('touch-ui').style.left = '0'; } }
        function handleGamepadSystem() { const gps = navigator.getGamepads(); if(!gps) return; if(InputMap.p1?.type === 'gamepad') { const gp = gps[InputMap.p1.index]; if(gp) { if(gp.buttons[9].pressed) { if(!PauseData.lastState && Sys.mode===1) { Sys.paused = !Sys.paused; document.getElementById('pause-screen').style.display = Sys.paused?'flex':'none'; } PauseData.lastState=true; } else PauseData.lastState=false; if((gp.buttons[2].pressed || gp.buttons[5].pressed || gp.buttons[7].pressed) && !Sys.paused) attack(0); } } if(Sys.mode === 1 && !Sys.paused) { for(let i=0; i<gps.length; i++) { const gp = gps[i]; if(gp && (!InputMap.p1 || (InputMap.p1.type !== 'gamepad' || InputMap.p1.index !== i))) { if(gp.buttons[9].pressed) { const now = Date.now(); if(now - P2JoinData.lastPressTime > 500) P2JoinData.presses = 0; if(now - P2JoinData.lastPressTime > 200) { P2JoinData.presses++; P2JoinData.lastPressTime = now; if(P2JoinData.presses >= 2) joinPlayer2(i); } } } } } }
        const TouchData = { moveX: 0, moveZ: 0, lookX: 0, lookY: 0, jump: false, attack: false, joyID: null, lookID: null };
        function initTouch() { const ui = document.getElementById('touch-ui'); const joyZone = document.getElementById('joystick-zone'); const joyKnob = document.getElementById('joystick-knob'); const lookZone = document.getElementById('touch-right-zone'); const jumpBtn = document.getElementById('btn-jump'); const attackBtn = document.getElementById('btn-attack'); ui.style.display = 'block'; if(Sys.mode === 2) { const p1Touch = InputMap.p1?.type === 'touch'; ui.style.left = p1Touch ? '0' : '50%'; ui.style.width = '50%'; } let joyStart = {x:0, y:0}; joyZone.addEventListener('touchstart', e => { e.preventDefault(); const t = e.changedTouches[0]; TouchData.joyID = t.identifier; joyStart.x = t.clientX; joyStart.y = t.clientY; }); joyZone.addEventListener('touchmove', e => { e.preventDefault(); for(let i=0; i<e.changedTouches.length; i++) { if(e.changedTouches[i].identifier === TouchData.joyID) { let dx = e.changedTouches[i].clientX - joyStart.x; let dy = e.changedTouches[i].clientY - joyStart.y; const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 50); const angle = Math.atan2(dy, dx); joyKnob.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`; TouchData.moveX = (Math.cos(angle)*dist)/50; TouchData.moveZ = (Math.sin(angle)*dist)/50; } } }); joyZone.addEventListener('touchend', e => { e.preventDefault(); for(let i=0; i<e.changedTouches.length; i++) { if(e.changedTouches[i].identifier === TouchData.joyID) { TouchData.joyID = null; TouchData.moveX = 0; TouchData.moveZ = 0; joyKnob.style.transform = `translate(-50%, -50%)`; } } }); let lookStart = {x:0, y:0}; lookZone.addEventListener('touchstart', e => { e.preventDefault(); if(e.target !== jumpBtn && e.target !== attackBtn) { const t = e.changedTouches[0]; TouchData.lookID = t.identifier; lookStart.x = t.clientX; lookStart.y = t.clientY; } }); lookZone.addEventListener('touchmove', e => { e.preventDefault(); for(let i=0; i<e.changedTouches.length; i++) { if(e.changedTouches[i].identifier === TouchData.lookID) { TouchData.lookX = (e.changedTouches[i].clientX - lookStart.x); TouchData.lookY = (e.changedTouches[i].clientY - lookStart.y); lookStart.x = e.changedTouches[i].clientX; lookStart.y = e.changedTouches[i].clientY; } } }); lookZone.addEventListener('touchend', e => { for(let i=0; i<e.changedTouches.length; i++) { if(e.changedTouches[i].identifier === TouchData.lookID) TouchData.lookID = null; } }); jumpBtn.addEventListener('touchstart', e => { e.preventDefault(); TouchData.jump = true; }); jumpBtn.addEventListener('touchend', e => { e.preventDefault(); TouchData.jump = false; }); attackBtn.addEventListener('touchstart', e => { e.preventDefault(); TouchData.attack = true; }); attackBtn.addEventListener('touchend', e => { e.preventDefault(); TouchData.attack = false; }); }

        let mx=0, my=0; document.addEventListener('mousemove', e => { if(document.pointerLockElement) { mx+=e.movementX; my+=e.movementY; } });
        function checkCol(pos) { const padding = 1.2; if(isWall(pos.x+padding, pos.z) || isWall(pos.x-padding, pos.z) || isWall(pos.x, pos.z+padding) || isWall(pos.x, pos.z-padding)) return true; return false; }
        function isWall(x, z) { const gx = Math.round(x/BS + WS/2); const gz = Math.round(z/BS + WS/2); if(gx<0||gx>=WS||gz<0||gz>=WS) return true; return map[gx][gz] === 1; }

        function animate() {
            requestAnimationFrame(animate); handleGamepadSystem(); if(Sys.paused) return;
            const dt = Math.min(clock.getDelta(), 0.1); const now = Date.now();

            Sys.players.forEach((p,i) => {
                let inputX = 0, inputZ = 0, rotY = 0, rotX = 0;
                if(!Sys.isGameOver) {
                    if(p.inp.type === 'keyboard') { if(keys['KeyW']) inputZ = -1; if(keys['KeyS']) inputZ = 1; if(keys['KeyA']) inputX = -1; if(keys['KeyD']) inputX = 1; if(keys['Space'] && p.onGround) { p.vel.y = PHYS.jumpForce; playSound('jump'); } rotY = -mx * 0.006; rotX = -my * 0.006; }
                    else if(p.inp.type === 'touch') { inputX = TouchData.moveX; inputZ = TouchData.moveZ; if(TouchData.jump && p.onGround) { p.vel.y = PHYS.jumpForce; playSound('jump'); } rotY = -TouchData.lookX * PHYS.lookSpeed; rotX = -TouchData.lookY * PHYS.lookSpeed; if(TouchData.attack) { attack(p.id-1); TouchData.attack = false; } TouchData.lookX=0; TouchData.lookY=0; }
                    else if(p.inp.type === 'gamepad') { const gp = navigator.getGamepads()[p.inp.index]; if(gp) { if(Math.abs(gp.axes[0])>0.1) inputX = gp.axes[0]; if(Math.abs(gp.axes[1])>0.1) inputZ = gp.axes[1]; if(gp.buttons[0].pressed && p.onGround) { p.vel.y = PHYS.jumpForce; playSound('jump'); } if(Math.abs(gp.axes[2])>0.1) rotY = -gp.axes[2]*0.04; if(Math.abs(gp.axes[3])>0.1) rotX = -gp.axes[3]*0.04; } }
                }
                p.obj.rotation.y += rotY; p.rotX = Math.max(-1.5, Math.min(1.5, p.rotX + rotX)); p.cam.rotation.x = p.rotX;
                const fwd = new THREE.Vector3(0,0,1).applyQuaternion(p.obj.quaternion); fwd.y=0; fwd.normalize(); const rgt = new THREE.Vector3(1,0,0).applyQuaternion(p.obj.quaternion); rgt.y=0; rgt.normalize();
                const move = new THREE.Vector3(); move.addScaledVector(fwd, inputZ); move.addScaledVector(rgt, inputX); if(move.length()>1) move.normalize();
                if (move.lengthSq() > 0 && p.onGround && !Sys.isGameOver && now - p.lastStepTime > 450) { playSound('step'); p.lastStepTime = now; }
                p.vel.x = move.x * PHYS.speed; p.vel.z = move.z * PHYS.speed; p.vel.y -= PHYS.gravity * dt;
                p.obj.position.x += p.vel.x * dt; if(checkCol(p.obj.position)) p.obj.position.x -= p.vel.x * dt; p.obj.position.z += p.vel.z * dt; if(checkCol(p.obj.position)) p.obj.position.z -= p.vel.z * dt; p.obj.position.y += p.vel.y * dt;
                if(p.obj.position.y < 9.0) { p.obj.position.y = 9.0; p.onGround = true; p.vel.y = 0; } else p.onGround = false;
                if(p.id === 1) document.getElementById('health-bar').style.width = Math.max(0, p.hp) + '%';
                if(p.hp <= 0 && !Sys.isGameOver) { Sys.isGameOver = true; document.exitPointerLock(); document.getElementById('game-over-screen').style.display = 'flex'; }
            });

            const zSpeed = 5.5;
            Sys.zombies.forEach(z => {
                let closest = 999, target = null;
                Sys.players.forEach(p => { const d = p.obj.position.distanceTo(z.obj.position); if(d < closest && p.hp > 0) { closest = d; target = p; } });
                if(target && closest < 80) {
                    z.obj.lookAt(target.obj.position.x, 9, target.obj.position.z);
                    const fwd = new THREE.Vector3(0,0,1).applyQuaternion(z.obj.quaternion); z.obj.position.addScaledVector(fwd, zSpeed * dt);
                    if(checkCol(z.obj.position)) z.obj.position.addScaledVector(fwd, -zSpeed * dt);
                    if(closest < 2.5 && Math.random() < 0.04 && !Sys.isGameOver) { 
                        target.hp -= 10; playSound('hurt');
                        const ov = document.getElementById('damage-overlay'); ov.style.opacity = 0.5; setTimeout(()=>ov.style.opacity=0, 100); 
                    }
                }
            });

            if(InputMap.p1?.type==='keyboard') { mx=0; my=0; }
            const w=window.innerWidth, h=window.innerHeight;
            Sys.players.forEach((p,i)=>{
                if(p.model) p.model.visible = false;
                if(Sys.players.length === 1) { p.cam.aspect=w/h; p.cam.updateProjectionMatrix(); renderer.setViewport(0,0,w,h); renderer.setScissor(0,0,w,h); renderer.setScissorTest(true); renderer.render(scene, p.cam); } 
                else { const l=i===0?0:w/2; p.cam.aspect=(w/2)/h; p.cam.updateProjectionMatrix(); renderer.setViewport(l,0,w/2,h); renderer.setScissor(l,0,w/2,h); renderer.setScissorTest(true); renderer.render(scene, p.cam); }
                if(p.model) p.model.visible = true;
            });
        }
        window.addEventListener('resize', ()=>renderer.setSize(window.innerWidth, window.innerHeight));
    </script>
</body>
</html>
