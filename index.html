<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Backrooms: Perfect Movement</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background: #eee; 
            font-family: 'Courier New', Courier, monospace; 
            user-select: none; -webkit-user-select: none; 
            touch-action: none; 
        }
        
        canvas { display: block; }

        #fs-btn {
            position: absolute; top: 10px; left: 10px; z-index: 1000;
            background: rgba(0, 0, 0, 0.5); color: #fff; border: 2px solid #fff;
            padding: 8px 12px; cursor: pointer; font-weight: bold; pointer-events: auto;
            font-family: sans-serif;
        }

        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #e0e0e0; 
            display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 50; color: #333;
        }
        h1 { font-size: 60px; color: #444; text-shadow: 2px 2px 0px #aaa; margin: 0 0 20px 0; letter-spacing: 2px; text-align: center; }
        
        .btn {
            padding: 15px 40px; font-size: 20px; background: #777; color: #fff;
            border: 4px solid #555; border-left-color: #999; border-top-color: #999;
            cursor: pointer; margin: 10px; min-width: 250px; font-family: 'Courier New', monospace; font-weight: bold;
        }
        .btn:hover { background: #888; color: #ff0; }

        #setup-panel {
            background: #ccc; border: 2px solid #555; padding: 30px;
            display: flex; flex-direction: column; gap: 20px; width: 90%; max-width: 500px;
        }
        .player-row { display: flex; justify-content: space-between; align-items: center; }
        select { padding: 10px; background: #555; color: #fff; border: 2px solid #333; }

        #ui-layer { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .player-screen { position: absolute; top: 0; height: 100%; box-sizing: border-box; overflow: hidden; }
        #p1-screen { left: 0; width: 100%; }
        #p2-screen { left: 50%; width: 50%; display: none; border-left: 2px solid #fff; }

        /* MC JAVA UI */
        .mc-crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%);
        }
        .mc-crosshair::before, .mc-crosshair::after {
            content: ''; position: absolute; background: rgba(200, 200, 200, 0.8); 
            mix-blend-mode: difference; 
        }
        .mc-crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; } 
        .mc-crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }

        .mc-hotbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 2px;
            background: rgba(0,0,0,0.4); padding: 3px; border-radius: 2px;
            pointer-events: auto; z-index: 55;
        }
        .mc-slot {
            width: 40px; height: 40px;
            border: 2px solid #555; border-top-color: #777; border-left-color: #777;
            background: rgba(0,0,0,0.3); cursor: pointer;
        }
        .mc-slot.active { border: 3px solid #fff; background: rgba(255,255,255,0.1); }
        .mc-slot:active { background: rgba(255,255,255,0.3); }

        .hud-text {
            position: absolute; bottom: 70px; left: 50%; transform: translateX(-50%);
            font-size: 24px; font-weight: bold; color: #f22; text-shadow: 2px 2px 0 #000;
        }

        /* TOUCH CONTROLS */
        #touch-layer {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 40; touch-action: none; 
        }
        #zone-move { position: absolute; bottom: 0; left: 0; width: 40%; height: 60%; pointer-events: auto; }
        #zone-look { position: absolute; bottom: 0; right: 0; width: 60%; height: 100%; pointer-events: auto; }
        
        #joystick-bg {
            position: absolute; width: 120px; height: 120px; border-radius: 50%;
            background: rgba(0,0,0,0.1); border: 2px solid rgba(0,0,0,0.3);
            display: none; pointer-events: none; transform: translate(-50%, -50%);
        }
        #joystick-head {
            position: absolute; width: 50px; height: 50px; border-radius: 50%;
            background: rgba(0,0,0,0.5); left: 35px; top: 35px; pointer-events: none;
        }

        .touch-btn {
            position: absolute; width: 70px; height: 70px; border-radius: 10px;
            background: rgba(200, 200, 200, 0.3); border: 4px solid #555;
            color: white; font-weight: bold; display: flex; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 50;
        }
        #btn-shoot { bottom: 90px; right: 30px; background: rgba(200, 50, 50, 0.4); }
        #btn-jump { bottom: 180px; right: 50px; }

        .local-death-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(100, 0, 0, 0.6); display: none;
            flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 60; color: white;
        }
    </style>
</head>
<body>

    <button id="fs-btn" onclick="toggleFullScreen()">TAM EKRAN</button>

    <div id="menu-screen" class="screen">
        <h1>BACKROOMS</h1>
        <p>JAVA EDITION UI</p>
        <button class="btn" onclick="goToSetup(1)">TEK OYUNCU</button>
        <button class="btn" onclick="goToSetup(2)">2 OYUNCU</button>
    </div>

    <div id="setup-screen" class="screen" style="display:none;">
        <h2>AYARLAR</h2>
        <div id="setup-panel">
            <div class="player-row">
                <label>P1</label>
                <select id="p1-input"><option value="touch">Dokunmatik</option><option value="keyboard">Klavye & Mouse</option></select>
            </div>
            <div class="player-row" id="p2-row">
                <label>P2</label>
                <select id="p2-input"><option value="gamepad_0">Gamepad 1</option><option value="keyboard">Klavye & Mouse</option></select>
            </div>
        </div>
        <button class="btn" onclick="startGame()">BAŞLAT</button>
    </div>

    <div id="ui-layer">
        <div id="touch-layer">
            <div id="zone-move"></div><div id="zone-look"></div>
            <div id="joystick-bg"><div id="joystick-head"></div></div>
            <div id="btn-shoot" class="touch-btn">ATK</div>
            <div id="btn-jump" class="touch-btn">JMP</div>
        </div>

        <div id="p1-screen" class="player-screen">
            <div class="mc-crosshair"></div>
            <div class="hud-text" id="hp1">HP: 100</div>
            <div class="mc-hotbar" id="p1-hotbar">
                <div class="mc-slot active" onclick="selectSlot(0, 0)"></div>
                <div class="mc-slot" onclick="selectSlot(0, 1)"></div>
                <div class="mc-slot" onclick="selectSlot(0, 2)"></div>
                <div class="mc-slot" onclick="selectSlot(0, 3)"></div>
                <div class="mc-slot" onclick="selectSlot(0, 4)"></div>
                <div class="mc-slot" onclick="selectSlot(0, 5)"></div>
                <div class="mc-slot" onclick="selectSlot(0, 6)"></div>
                <div class="mc-slot" onclick="selectSlot(0, 7)"></div>
                <div class="mc-slot" onclick="selectSlot(0, 8)"></div>
            </div>
            <div id="p1-death" class="local-death-screen">
                <h1 style="font-size:40px;">YOU DIED!</h1>
                <button class="btn" onclick="respawnPlayer(0)">RESPAWN</button>
            </div>
        </div>

        <div id="p2-screen" class="player-screen">
            <div class="mc-crosshair"></div>
            <div class="hud-text" id="hp2">HP: 100</div>
            <div class="mc-hotbar" id="p2-hotbar">
                <div class="mc-slot active" onclick="selectSlot(1, 0)"></div>
                <div class="mc-slot" onclick="selectSlot(1, 1)"></div>
                <div class="mc-slot" onclick="selectSlot(1, 2)"></div>
                <div class="mc-slot" onclick="selectSlot(1, 3)"></div>
                <div class="mc-slot" onclick="selectSlot(1, 4)"></div>
                <div class="mc-slot" onclick="selectSlot(1, 5)"></div>
                <div class="mc-slot" onclick="selectSlot(1, 6)"></div>
                <div class="mc-slot" onclick="selectSlot(1, 7)"></div>
                <div class="mc-slot" onclick="selectSlot(1, 8)"></div>
            </div>
            <div id="p2-death" class="local-death-screen">
                <h1 style="font-size:40px;">YOU DIED!</h1>
                <button class="btn" onclick="respawnPlayer(1)">RESPAWN</button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';

        const RENDER_DISTANCE = 70;
        const MAX_ZOMBIES = 15;
        const SPAWN_DELAY_MS = 3000;
        const START_DELAY_MS = 5000;
        
        // AYARLANMIŞ HIZ VE ÇARPIŞMA DEĞERLERİ
        const MOVE_SPEED = 6; // Eskiden 12 idi, şimdi 6 (Yavaşlatıldı)
        const COLLISION_DISTANCE = 3.0; // Eskiden 2.5 idi (Daha uzakta durur)

        let scene, renderer;
        let players = [];
        let bullets = [];
        let zombies = [];
        let walls = [];
        let lastTime = 0;
        let selectedMode = 1;
        const keys = {};
        
        let gameStartTime = 0;
        let lastSpawnTime = 0;

        const touchState = {
            moveId: null, lookId: null, startX: 0, startY: 0, moveX: 0, moveY: 0,
            lastLookX: 0, lastLookY: 0, lookDeltaX: 0, lookDeltaY: 0, shoot: false, jump: false
        };

        window.toggleFullScreen = function() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(e=>{});
            else if (document.exitFullscreen) document.exitFullscreen();
        };

        window.goToSetup = function(mode) {
            selectedMode = mode;
            document.getElementById('menu-screen').style.display = 'none';
            document.getElementById('setup-screen').style.display = 'flex';
            if(mode === 1) document.getElementById('p2-row').style.display = 'none';
            else document.getElementById('p2-row').style.display = 'flex';
            updateControllerList();
        };

        function updateControllerList() {
            const gps = navigator.getGamepads ? navigator.getGamepads() : [];
            const sel = document.getElementById('p1-input');
            if(sel.options.length < 3 && gps[0]) sel.innerHTML += `<option value="gamepad_0">Gamepad 1</option>`;
        }

        window.startGame = function() {
            document.getElementById('setup-screen').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block';
            const p1Type = document.getElementById('p1-input').value;
            const p2Type = document.getElementById('p2-input').value;

            if (p1Type === 'touch') {
                document.getElementById('touch-layer').style.display = 'block';
                initTouchControls();
                toggleFullScreen();
            }

            if (selectedMode === 2) {
                document.getElementById('p1-screen').style.width = '50%';
                document.getElementById('p2-screen').style.display = 'block';
            }

            initThreeJS(p1Type, p2Type);
            gameStartTime = performance.now();

            if (p1Type === 'keyboard') {
                document.body.requestPointerLock();
                document.addEventListener('click', () => {
                     if(document.getElementById('p1-death').style.display === 'none')
                        document.body.requestPointerLock();
                });
            }
        };

        window.respawnPlayer = function(id) {
            const p = players[id];
            if(p) {
                p.hp = 100; p.dead = false; p.mesh.rotation.z = 0;
                p.mesh.position.set(id*5, 2, 0);
                document.getElementById('p'+(id+1)+'-death').style.display = 'none';
                document.getElementById('hp'+(id+1)).innerText = "HP: 100";
                
                if(p.inputType === 'touch') document.getElementById('touch-layer').style.display = 'block';
                
                zombies.forEach(z => scene.remove(z.mesh));
                zombies = [];
                gameStartTime = performance.now(); 
            }
        };

        window.selectSlot = function(playerId, slotIndex) {
            const barId = playerId === 0 ? 'p1-hotbar' : 'p2-hotbar';
            const bar = document.getElementById(barId);
            if (!bar) return;
            const slots = bar.children;
            for(let i=0; i<slots.length; i++) slots[i].classList.remove('active');
            slots[slotIndex].classList.add('active');
        }

        function initTouchControls() {
            const moveZone = document.getElementById('zone-move');
            const lookZone = document.getElementById('zone-look');
            const joyBg = document.getElementById('joystick-bg');
            const joyHead = document.getElementById('joystick-head');
            const bShoot = document.getElementById('btn-shoot');
            const bJump = document.getElementById('btn-jump');
            let stickOrigin = {x:0, y:0};

            moveZone.addEventListener('touchstart', e => {
                e.preventDefault(); if (touchState.moveId !== null) return;
                const touch = e.changedTouches[0];
                touchState.moveId = touch.identifier;
                touchState.startX = touch.clientX; touchState.startY = touch.clientY;
                joyBg.style.display = 'block';
                joyBg.style.left = touch.clientX + 'px'; joyBg.style.top = touch.clientY + 'px';
                joyHead.style.transform = `translate(0px, 0px)`;
            }, {passive: false});

            moveZone.addEventListener('touchmove', e => {
                e.preventDefault();
                for (let i=0; i<e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    if (touch.identifier === touchState.moveId) {
                        const maxDist = 50;
                        let dx = touch.clientX - touchState.startX; let dy = touch.clientY - touchState.startY;
                        const dist = Math.min(Math.sqrt(dx*dx + dy*dy), maxDist);
                        const angle = Math.atan2(dy, dx);
                        const lx = Math.cos(angle) * dist; const ly = Math.sin(angle) * dist;
                        joyHead.style.transform = `translate(${lx}px, ${ly}px)`;
                        touchState.moveX = lx / maxDist; touchState.moveY = ly / maxDist;
                    }
                }
            }, {passive: false});

            moveZone.addEventListener('touchend', handleMoveEnd, {passive: false});
            moveZone.addEventListener('touchcancel', handleMoveEnd, {passive: false});

            function handleMoveEnd(e) {
                e.preventDefault();
                for (let i=0; i<e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchState.moveId) {
                        touchState.moveId = null; touchState.moveX = 0; touchState.moveY = 0;
                        joyBg.style.display = 'none';
                    }
                }
            }

            lookZone.addEventListener('touchstart', e => {
                e.preventDefault(); if (touchState.lookId !== null) return;
                const touch = e.changedTouches[0];
                touchState.lookId = touch.identifier;
                touchState.lastLookX = touch.clientX; touchState.lastLookY = touch.clientY;
            }, {passive: false});

            lookZone.addEventListener('touchmove', e => {
                e.preventDefault();
                for (let i=0; i<e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    if (touch.identifier === touchState.lookId) {
                        touchState.lookDeltaX += touch.clientX - touchState.lastLookX;
                        touchState.lookDeltaY += touch.clientY - touchState.lastLookY;
                        touchState.lastLookX = touch.clientX; touchState.lastLookY = touch.clientY;
                    }
                }
            }, {passive: false});

            lookZone.addEventListener('touchend', e => {
                e.preventDefault();
                for (let i=0; i<e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchState.lookId) touchState.lookId = null;
                }
            }, {passive: false});

            bShoot.addEventListener('touchstart', e => { e.preventDefault(); touchState.shoot = true; });
            bShoot.addEventListener('touchend', e => { e.preventDefault(); touchState.shoot = false; });
            bJump.addEventListener('touchstart', e => { e.preventDefault(); touchState.jump = true; });
            bJump.addEventListener('touchend', e => { e.preventDefault(); touchState.jump = false; });
        }

        function initThreeJS(p1Input, p2Input) {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xeee8d5); 
            
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClear = false;
            document.body.appendChild(renderer.domElement);

            createWorld();

            const aspect = selectedMode === 1 ? window.innerWidth/window.innerHeight : (window.innerWidth/2)/window.innerHeight;
            players.push(new Player(0, 0x00ffff, p1Input, aspect));
            if (selectedMode === 2) {
                players.push(new Player(1, 0xff00ff, p2Input, aspect));
                players[1].mesh.position.x = 3; 
            }

            document.addEventListener('keydown', e => keys[e.code] = true);
            document.addEventListener('keyup', e => keys[e.code] = false);
            document.addEventListener('mousemove', e => {
                if (document.pointerLockElement === document.body) players.forEach(p => { if (p.inputType === 'keyboard' && !p.dead) p.mouseLook(e.movementX, e.movementY); });
            });
            document.addEventListener('mousedown', () => {
                if (document.pointerLockElement === document.body) players.forEach(p => { if (p.inputType === 'keyboard' && !p.dead) p.tryShoot(); });
            });

            requestAnimationFrame(animate);
        }

        class Player {
            constructor(id, color, inputType, aspect) {
                this.id = id; this.inputType = inputType; 
                this.hp = 100; this.dead = false;
                this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
                this.pitch = 0; this.yaw = 0;
                this.velocity = new THREE.Vector3(); this.isGrounded = false;
                this.mesh = new THREE.Group(); this.mesh.position.set(0, 2, 0);
                
                const bodyGeo = new THREE.BoxGeometry(1, 3, 1);
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0x333, emissive: color, emissiveIntensity: 0.5 });
                this.body = new THREE.Mesh(bodyGeo, bodyMat);
                this.mesh.add(this.body);
                scene.add(this.mesh);
                this.shootCooldown = 0;
            }

            update(dt) {
                if (this.dead) return;
                let moveX=0, moveZ=0, rotX=0, rotY=0, jump=false, shoot=false;

                if (this.inputType === 'touch') {
                    moveX = touchState.moveX; moveZ = touchState.moveY; 
                    rotX = touchState.lookDeltaX * 1.5; rotY = touchState.lookDeltaY * 1.5;
                    touchState.lookDeltaX = 0; touchState.lookDeltaY = 0;
                    jump = touchState.jump; shoot = touchState.shoot;
                } else if (this.inputType === 'keyboard') {
                    if (keys['KeyW']) moveZ = -1; if (keys['KeyS']) moveZ = 1;
                    if (keys['KeyA']) moveX = -1; if (keys['KeyD']) moveX = 1;
                    if (keys['Space']) jump = true;
                } else if (this.inputType.startsWith('gamepad')) {
                    const idx = parseInt(this.inputType.split('_')[1]);
                    const gp = navigator.getGamepads()[idx];
                    if (gp) {
                        if (Math.abs(gp.axes[0]) > 0.1) moveX = gp.axes[0];
                        if (Math.abs(gp.axes[1]) > 0.1) moveZ = gp.axes[1];
                        if (Math.abs(gp.axes[2]) > 0.1) rotX = gp.axes[2] * 60; 
                        if (Math.abs(gp.axes[3]) > 0.1) rotY = gp.axes[3] * 40;
                        if (gp.buttons[0].pressed) jump = true;
                        if (gp.buttons[7].pressed) shoot = true;
                    }
                }

                if (this.inputType === 'touch') { this.yaw -= rotX * 0.005; this.pitch -= rotY * 0.005; }
                else { this.yaw -= rotX * dt; this.pitch -= rotY * dt; }
                this.pitch = Math.max(-1.5, Math.min(1.5, this.pitch));

                const speed = MOVE_SPEED * dt; // GÜNCELLENMİŞ HIZ
                const dir = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), this.yaw);
                const side = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), this.yaw);
                const moveVec = new THREE.Vector3();
                moveVec.add(dir.multiplyScalar(-moveZ));
                moveVec.add(side.multiplyScalar(moveX));

                // WALL SLIDING (Duvar Kayma)
                const velocityVec = moveVec.clone();
                // X Hareketi
                let nextPos = this.mesh.position.clone();
                nextPos.x += velocityVec.x * speed; // Speed faktörü
                if (!checkWallCollision(nextPos)) {
                    this.mesh.position.x += velocityVec.x * speed;
                }
                // Z Hareketi
                nextPos = this.mesh.position.clone();
                nextPos.z += velocityVec.z * speed;
                if (!checkWallCollision(nextPos)) {
                    this.mesh.position.z += velocityVec.z * speed;
                }

                if (jump && this.isGrounded) { this.velocity.y = 12; this.isGrounded = false; }
                this.velocity.y -= 30 * dt;
                this.mesh.position.y += this.velocity.y * dt;
                if (this.mesh.position.y < 2) { this.mesh.position.y = 2; this.velocity.y = 0; this.isGrounded = true; }

                this.mesh.rotation.y = this.yaw;
                this.camera.position.copy(this.mesh.position); this.camera.position.y += 0.8;
                this.camera.rotation.set(this.pitch, this.yaw, 0, 'YXZ');

                if (shoot) this.tryShoot();
                if (this.shootCooldown > 0) this.shootCooldown -= dt;
            }

            mouseLook(mx, my) {
                this.yaw -= mx * 0.002; this.pitch -= my * 0.002;
                this.pitch = Math.max(-1.5, Math.min(1.5, this.pitch));
            }

            tryShoot() {
                if (this.shootCooldown <= 0) {
                    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(this.camera.quaternion);
                    const bGeo = new THREE.BoxGeometry(0.05, 0.05, 1);
                    const bMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Yeşil mermi
                    const bullet = new THREE.Mesh(bGeo, bMat);
                    bullet.position.copy(this.camera.position).add(dir.clone().multiplyScalar(1));
                    bullet.quaternion.copy(this.camera.quaternion);
                    bullet.userData = { vel: dir.multiplyScalar(80), life: 1.0 };
                    const flash = new THREE.PointLight(0x00ff00, 2, 5);
                    flash.position.copy(bullet.position); scene.add(flash); setTimeout(()=>scene.remove(flash), 50);
                    scene.add(bullet); bullets.push(bullet);
                    this.shootCooldown = 0.15;
                }
            }

            takeDamage(val) {
                if (this.dead) return;
                this.hp -= val;
                document.getElementById('hp'+(this.id+1)).innerText = "HP: " + Math.ceil(Math.max(0, this.hp));
                if (this.hp <= 0) {
                    this.dead = true; this.mesh.rotation.z = Math.PI/2; this.mesh.position.y = 0.5;
                    if(this.inputType === 'touch') document.getElementById('touch-layer').style.display = 'none';
                    document.exitPointerLock();
                    document.getElementById('p'+(this.id+1)+'-death').style.display = 'flex';
                }
            }
        }

        class Zombie {
            constructor() {
                const geo = new THREE.BoxGeometry(1, 2.5, 1);
                const mat = new THREE.MeshStandardMaterial({ color: 0x222, emissive: 0xff3333, emissiveIntensity: 0.8 });
                this.mesh = new THREE.Mesh(geo, mat);
                this.respawn(); scene.add(this.mesh);
                this.speed = 3 + Math.random() * 3;
            }
            respawn() {
                this.hp = 3;
                const targets = players.filter(p => !p.dead);
                if (targets.length === 0) return;
                const t = targets[Math.floor(Math.random()*targets.length)];
                const angle = Math.random()*Math.PI*2; const dist = 30 + Math.random()*20;
                this.mesh.position.set(t.mesh.position.x + Math.cos(angle)*dist, 1.25, t.mesh.position.z + Math.sin(angle)*dist);
            }
            update(dt) {
                let target = null; let minD = Infinity;
                players.forEach(p => { if(!p.dead) { const d = this.mesh.position.distanceTo(p.mesh.position); if(d<minD){minD=d;target=p;} } });
                if (target) {
                    this.mesh.lookAt(target.mesh.position.x, 1.25, target.mesh.position.z);
                    const dir = new THREE.Vector3(); this.mesh.getWorldDirection(dir);
                    this.mesh.position.add(dir.multiplyScalar(this.speed * dt));
                    if(minD < 1.5) { target.takeDamage(1); this.mesh.position.add(dir.negate().multiplyScalar(0.5)); }
                }
            }
        }

        function createWorld() {
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(300,300), new THREE.MeshStandardMaterial({color:0xdddddd, roughness:0.8}));
            floor.rotation.x = -Math.PI/2; floor.name="floor"; scene.add(floor);
            const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(300,300), new THREE.MeshStandardMaterial({color:0xffffaa, roughness:0.8}));
            ceiling.rotation.x = Math.PI/2; ceiling.position.y = 8; scene.add(ceiling);
            const boxGeo = new THREE.BoxGeometry(4,8,4);
            const boxMat = new THREE.MeshStandardMaterial({color:0xcccccc, emissive: 0xcccccc, emissiveIntensity: 0.2}); 
            for(let i=0; i<150; i++) {
                const wall = new THREE.Mesh(boxGeo, boxMat);
                const a = Math.random()*Math.PI*2; const d = 15 + Math.random()*50;
                wall.position.set(Math.cos(a)*d, 4, Math.sin(a)*d);
                scene.add(wall); walls.push(wall);
            }
            scene.add(new THREE.AmbientLight(0xaaaaaa));
        }

        function checkWallCollision(pos) {
            for(let w of walls) {
                const dx = pos.x - w.position.x; const dz = pos.z - w.position.z;
                // ÇARPIŞMA MESAFESİ ARTTIRILDI
                if(Math.sqrt(dx*dx + dz*dz) < COLLISION_DISTANCE) return true;
            }
            return false;
        }

        function animate(time) {
            const dt = (time - lastTime) / 1000; lastTime = time;
            const now = performance.now();
            if (now - gameStartTime > START_DELAY_MS) {
                if (now - lastSpawnTime > SPAWN_DELAY_MS && zombies.length < MAX_ZOMBIES) {
                    zombies.push(new Zombie()); lastSpawnTime = now;
                }
            }

            players.forEach(p => p.update(dt));
            
            const refP = players.find(p=>!p.dead) || players[0];
            if(refP) {
                const f = scene.getObjectByName("floor");
                if(f) { f.position.x = refP.mesh.position.x; f.position.z = refP.mesh.position.z; }
                walls.forEach(w => {
                    if(w.position.distanceTo(refP.mesh.position) > RENDER_DISTANCE) {
                        const a = Math.random()*Math.PI*2; const d = 15 + Math.random()*RENDER_DISTANCE;
                        w.position.set(refP.mesh.position.x + Math.cos(a)*d, 4, refP.mesh.position.z + Math.sin(a)*d);
                    }
                });
                zombies.forEach(z => { z.update(dt); if(z.mesh.position.distanceTo(refP.mesh.position) > RENDER_DISTANCE + 10) z.respawn(); });
            }

            bullets.forEach((b,i) => {
                b.position.add(b.userData.vel.clone().multiplyScalar(dt)); b.userData.life -= dt;
                let hit = false;
                for(let z of zombies) { if(b.position.distanceTo(z.mesh.position) < 1.5) { z.hp--; hit = true; if(z.hp<=0) z.respawn(); break; } }
                if(hit || b.userData.life <= 0) { scene.remove(b); bullets.splice(i,1); }
            });

            renderer.clear();
            const w = window.innerWidth, h = window.innerHeight;

            if (selectedMode === 1) {
                if(!players[0].dead) { 
                    renderer.setViewport(0,0,w,h); renderer.setScissor(0,0,w,h); renderer.setScissorTest(false); 
                    renderer.render(scene, players[0].camera); 
                }
            } else {
                renderer.setScissorTest(true);
                if(!players[0].dead) { 
                    renderer.setViewport(0,0,w/2,h); renderer.setScissor(0,0,w/2,h); 
                    renderer.render(scene, players[0].camera); 
                }
                if(!players[1].dead) { 
                    renderer.setViewport(w/2,0,w/2,h); renderer.setScissor(w/2,0,w/2,h); 
                    renderer.render(scene, players[1].camera); 
                }
            }
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(players[0]) players[0].camera.aspect = selectedMode===1 ? window.innerWidth/window.innerHeight : (window.innerWidth/2)/window.innerHeight;
            if(players[1]) players[1].camera.aspect = (window.innerWidth/2)/window.innerHeight;
            players.forEach(p => p.camera.updateProjectionMatrix());
        });
    </script>
</body>
</html>

