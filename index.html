<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Backrooms: Long Range Attack</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Minecraft', 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; touch-action: none; }
        
        /* UI LAYER */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }

        /* CAN BARI */
        #health-container {
            position: absolute; top: 20px; left: 20px;
            width: 200px; height: 20px;
            background: rgba(0,0,0,0.5); border: 2px solid white;
            border-radius: 10px; overflow: hidden;
        }
        #health-bar {
            width: 100%; height: 100%;
            background: #ff0000;
            transition: width 0.2s;
        }
        #damage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: red; opacity: 0; pointer-events: none;
            transition: opacity 0.1s; z-index: 5;
        }

        /* GAME OVER EKRANI */
        #game-over-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(50, 0, 0, 0.9);
            display: none; flex-direction: column; align-items: center; justify-content: center;
            color: white; z-index: 100; pointer-events: auto;
        }
        #game-over-screen h1 { font-size: 50px; color: #ff5555; text-shadow: 2px 2px 0 #000; margin: 0; }
        #game-over-screen p { font-size: 20px; margin-top: 10px; color: #ddd; }

        /* KONTROLLER */
        #joystick-zone {
            position: absolute; bottom: 50px; left: 50px;
            width: 140px; height: 140px;
            background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255,255,255,0.2);
            border-radius: 50%; pointer-events: auto; touch-action: none;
        }
        #joystick-knob {
            position: absolute; top: 50%; left: 50%; width: 60px; height: 60px;
            background: rgba(255, 200, 0, 0.6); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            box-shadow: 0 0 15px rgba(255, 200, 0, 0.4);
        }

        #touch-right-zone {
            position: absolute; top: 0; right: 0; width: 50%; height: 100%;
            pointer-events: auto; z-index: 20; touch-action: none;
        }
        
        #btn-jump {
            position: absolute; bottom: 60px; right: 40px;
            width: 90px; height: 90px; border-radius: 50%;
            background: rgba(200, 200, 200, 0.3); border: 2px solid rgba(255,255,255,0.4);
            pointer-events: auto; z-index: 30;
        }
        #btn-jump:active { background: rgba(255,255,255,0.6); transform: scale(0.95); }

        #btn-attack {
            position: absolute; bottom: 60px; right: 150px; 
            width: 70px; height: 70px; border-radius: 50%;
            background: rgba(255, 50, 50, 0.4); border: 2px solid rgba(255,200,200,0.4);
            pointer-events: auto; z-index: 30;
            display: flex; align-items: center; justify-content: center;
            color: white; font-weight: bold; font-size: 12px;
        }
        #btn-attack:active { background: rgba(255, 0, 0, 0.6); transform: scale(0.95); }

        /* MENU */
        #menu {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: #111; color: #ffea00; z-index: 1000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        .btn {
            padding: 20px 40px; font-size: 20px; background: #333; color: white;
            border: 2px solid #555; margin: 10px; border-radius: 10px; cursor: pointer; width: 80%; max-width: 300px;
        }
        .active-slot { border-color: #0f0; background: #003300; }
        #split-line { position: absolute; left: 50%; top: 0; width: 3px; height: 100%; background: #000; display: none; z-index: 5; transform: translateX(-50%); }
    </style>
</head>
<body>

    <div id="damage-overlay"></div>
    <div id="split-line"></div>

    <div id="ui-layer">
        <div id="health-container" style="display:none;">
            <div id="health-bar"></div>
        </div>
    </div>

    <div id="game-over-screen" onclick="location.reload()">
        <h1>ÖLDÜN!</h1>
        <p>Yeniden başlamak için ekrana dokun</p>
    </div>

    <div id="touch-ui" style="display:none;">
        <div id="joystick-zone"><div id="joystick-knob"></div></div>
        <div id="touch-right-zone"></div>
        <div id="btn-attack">SALDIR</div>
        <div id="btn-jump"></div>
    </div>

    <div id="menu">
        <h1>BACKROOMS MCPE</h1>
        <div id="p1-slot" class="btn">OYUNCU 1: Bekleniyor...</div>
        <div id="p2-slot" class="btn" style="display:none;">OYUNCU 2: Bekleniyor...</div>
        <div id="controls-hint" style="margin:20px; color:#aaa; text-align:center;">
            Mod Seçimi:<br>
            <button onclick="setMode(1)" style="padding:10px;">TEK KİŞİLİK</button>
            <button onclick="setMode(2)" style="padding:10px;">ÇİFT KİŞİLİK</button>
        </div>
        <button id="btn-start" style="display:none; background:#d4d400; color:black; font-weight:bold; padding:20px 50px;" onclick="startGame()">BAŞLAT</button>
        <p style="font-size:12px; color:#666;">Kontrol: Klavye (WASD+Space+F) veya Dokunmatik.</p>
        <button id="btn-touch" onclick="assignTouch()" style="background:#0055aa; color:white; padding:10px;">DOKUNMATİK SEÇ</button>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.126.0/build/three.module.js';

        const Sys = { mode: 1, players: [], ready: 0, active: false, zombies: [], isGameOver: false };
        const InputMap = { p1: null, p2: null };
        
        // HASSASİYET AYARLARI
        const PHYS = { 
            speed: 12.5, 
            gravity: 80.0, 
            jumpForce: 25.0, 
            lookSpeed: 0.012 
        };

        const tl = new THREE.TextureLoader();
        const tex = (u) => { const t = tl.load(u); t.magFilter = THREE.NearestFilter; return t; };
        
        // RESİMLER
        const texData = {
            wall: tex('./photos/brick.png'),
            floor: tex('./photos/cobblestone.png'),
            ceil: tex('./photos/acacia_trapdoor.png')
        };

        // DOKU TEKRARI (1 Resim = 1 Blok)
        Object.values(texData).forEach(t => { 
            if(t.isTexture) { 
                t.magFilter = THREE.NearestFilter; 
                t.wrapS = t.wrapT = THREE.RepeatWrapping; 
            } 
        });
        if(texData.wall) texData.wall.repeat.set(1, 7); // Dikeyde 7 tekrar

        const mat = {
            wall: texData.wall,
            floor: texData.floor,
            ceil: texData.ceil
        };

        // MODEL OLUŞTURUCU
        function createHumanoid(isZombie) {
            const group = new THREE.Group();
            const cSkin = isZombie ? 0x3d7a3d : 0xffccaa; 
            const cShirt = isZombie ? 0x3d7a3d : 0x00aaaa; 
            const cPants = 0x0000aa; 
            const matSkin = new THREE.MeshLambertMaterial({ color: cSkin });
            const matShirt = new THREE.MeshLambertMaterial({ color: cShirt });
            const matPants = new THREE.MeshLambertMaterial({ color: cPants });

            const head = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2.5, 2.5), matSkin);
            head.position.y = 8.25; group.add(head);
            const body = new THREE.Mesh(new THREE.BoxGeometry(2.6, 3.5, 1.3), matShirt);
            body.position.y = 5.25; group.add(body);
            
            const armGeo = new THREE.BoxGeometry(1, 3.5, 1);
            const rArm = new THREE.Mesh(armGeo, isZombie ? matShirt : matSkin);
            rArm.position.set(1.9, 5.25, 0);
            if(isZombie) { rArm.rotation.x = -Math.PI/2; rArm.position.y += 1; rArm.position.z += 1.5; }
            group.add(rArm);

            const lArm = new THREE.Mesh(armGeo, isZombie ? matShirt : matSkin);
            lArm.position.set(-1.9, 5.25, 0);
            if(isZombie) { lArm.rotation.x = -Math.PI/2; lArm.position.y += 1; lArm.position.z += 1.5; }
            group.add(lArm);

            const legGeo = new THREE.BoxGeometry(1.1, 3.5, 1.1);
            const rLeg = new THREE.Mesh(legGeo, matPants);
            rLeg.position.set(0.7, 1.75, 0); group.add(rLeg);
            const lLeg = new THREE.Mesh(legGeo, matPants);
            lLeg.position.set(-0.7, 1.75, 0); group.add(lLeg);

            return group;
        }

        window.setMode = (m) => {
            Sys.mode = m;
            if(m===2) document.getElementById('p2-slot').style.display = 'block';
            document.getElementById('controls-hint').style.display = 'none';
            checkInput();
        };
        window.assignTouch = () => assign('touch', 0);
        function checkInput() {
            if(Sys.active) return;
            const gps = navigator.getGamepads ? navigator.getGamepads() : [];
            for(let i=0; i<gps.length; i++) if(gps[i] && gps[i].buttons.some(b=>b.pressed)) assign('gamepad', i);
            requestAnimationFrame(checkInput);
        }
        window.addEventListener('keydown', e => { if(['KeyW','ArrowUp'].includes(e.code)) assign('keyboard', 0); });
        function assign(type, idx) {
            if(Sys.ready >= Sys.mode) return;
            if((InputMap.p1?.type===type && InputMap.p1.index===idx) || (InputMap.p2?.type===type && InputMap.p2.index===idx)) return;
            const pid = InputMap.p1 ? 2 : 1;
            InputMap['p'+pid] = { type, index: idx };
            const slot = document.getElementById('p'+pid+'-slot');
            slot.innerText = `OYUNCU ${pid}: ${type.toUpperCase()}`;
            slot.classList.add('active-slot');
            if(type==='touch') document.getElementById('btn-touch').style.display='none';
            Sys.ready++;
            if(Sys.ready === Sys.mode) document.getElementById('btn-start').style.display='block';
        }

        const TouchData = { moveX: 0, moveZ: 0, lookX: 0, lookY: 0, jump: false, attack: false, joyID: null, lookID: null };
        function initTouch() {
            const ui = document.getElementById('touch-ui');
            const joyZone = document.getElementById('joystick-zone');
            const joyKnob = document.getElementById('joystick-knob');
            const lookZone = document.getElementById('touch-right-zone');
            const jumpBtn = document.getElementById('btn-jump');
            const attackBtn = document.getElementById('btn-attack');

            ui.style.display = 'block';
            document.getElementById('health-container').style.display = 'block';

            if(Sys.mode === 2) {
                const p1Touch = InputMap.p1?.type === 'touch';
                ui.style.left = p1Touch ? '0' : '50%';
                ui.style.width = '50%';
            }

            let joyStart = {x:0, y:0};
            joyZone.addEventListener('touchstart', e => {
                e.preventDefault();
                const t = e.changedTouches[0];
                TouchData.joyID = t.identifier;
                joyStart.x = t.clientX; joyStart.y = t.clientY;
            });
            joyZone.addEventListener('touchmove', e => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if(t.identifier === TouchData.joyID) {
                        let dx = t.clientX - joyStart.x;
                        let dy = t.clientY - joyStart.y;
                        const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 50);
                        const angle = Math.atan2(dy, dx);
                        const jx = Math.cos(angle) * dist;
                        const jy = Math.sin(angle) * dist;
                        joyKnob.style.transform = `translate(calc(-50% + ${jx}px), calc(-50% + ${jy}px))`;
                        TouchData.moveX = jx / 50; TouchData.moveZ = jy / 50;
                    }
                }
            });
            joyZone.addEventListener('touchend', e => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === TouchData.joyID) {
                        TouchData.joyID = null;
                        TouchData.moveX = 0; TouchData.moveZ = 0;
                        joyKnob.style.transform = `translate(-50%, -50%)`;
                    }
                }
            });

            let lookStart = {x:0, y:0};
            lookZone.addEventListener('touchstart', e => {
                e.preventDefault();
                if(e.target !== jumpBtn && e.target !== attackBtn) {
                    const t = e.changedTouches[0];
                    TouchData.lookID = t.identifier;
                    lookStart.x = t.clientX; lookStart.y = t.clientY;
                }
            });
            lookZone.addEventListener('touchmove', e => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if(t.identifier === TouchData.lookID) {
                        TouchData.lookX = (t.clientX - lookStart.x);
                        TouchData.lookY = (t.clientY - lookStart.y);
                        lookStart.x = t.clientX; lookStart.y = t.clientY;
                    }
                }
            });
            lookZone.addEventListener('touchend', e => {
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === TouchData.lookID) TouchData.lookID = null;
                }
            });

            jumpBtn.addEventListener('touchstart', e => { e.preventDefault(); TouchData.jump = true; });
            jumpBtn.addEventListener('touchend', e => { e.preventDefault(); TouchData.jump = false; });
            attackBtn.addEventListener('touchstart', e => { e.preventDefault(); TouchData.attack = true; });
            attackBtn.addEventListener('touchend', e => { e.preventDefault(); TouchData.attack = false; });
        }

        window.startGame = () => {
            document.getElementById('menu').style.display = 'none';
            if(document.documentElement.requestFullscreen) document.documentElement.requestFullscreen().catch(()=>{});
            if(InputMap.p1?.type==='touch' || InputMap.p2?.type==='touch') initTouch();
            if(InputMap.p1?.type==='keyboard' || InputMap.p2?.type==='keyboard') document.body.requestPointerLock();
            initEngine();
        };

        let scene, renderer, clock;
        const map = [], WS = 40, BS = 5;
        const keys = {};

        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if(e.code === 'KeyF') attackZombie(0);
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        function initEngine() {
            Sys.active = true;
            clock = new THREE.Clock();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 0, 60);
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));

            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClear = false;
            document.body.appendChild(renderer.domElement);

            generateWorld();
            
            if(InputMap.p1) createPlayer(1, InputMap.p1);
            if(InputMap.p2) { createPlayer(2, InputMap.p2); document.getElementById('split-line').style.display='block'; }

            setInterval(trySpawnZombie, 2000); 
            animate();
        }

        function generateWorld() {
            const geo = new THREE.BoxGeometry(BS, BS*7, BS);
            const pln = new THREE.PlaneGeometry(BS, BS);
            const mW = new THREE.MeshLambertMaterial({ map: mat.wall });
            const mF = new THREE.MeshLambertMaterial({ map: mat.floor });
            const mC = new THREE.MeshLambertMaterial({ map: mat.ceil });

            for(let x=0; x<WS; x++) {
                map[x] = [];
                for(let z=0; z<WS; z++) {
                    const px = (x-WS/2)*BS, pz = (z-WS/2)*BS;
                    const f = new THREE.Mesh(pln, mF); f.rotation.x = -Math.PI/2; f.position.set(px,0,pz); scene.add(f);
                    const c = new THREE.Mesh(pln, mC); c.rotation.x = Math.PI/2; c.position.set(px,BS*7,pz); scene.add(c);
                    let w = (x===0||x===WS-1||z===0||z===WS-1) || (Math.random()<0.1 && Math.abs(x-WS/2)>2);
                    if(w) {
                        map[x][z] = 1;
                        const b = new THREE.Mesh(geo, mW); b.position.set(px,BS*3.5,pz); scene.add(b);
                    } else map[x][z] = 0;
                }
            }
        }

        function createPlayer(id, inp) {
            const o = new THREE.Object3D();
            const c = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
            o.add(c);
            const steve = createHumanoid(false);
            steve.position.y = -9.0; 
            o.add(steve);
            const l = new THREE.SpotLight(0xffaa00, 1, 25, 0.6); l.position.set(0,9,0); l.target.position.set(0,9,-1);
            o.add(l); o.add(l.target);
            o.position.set(id===1?-5:5, 9, 0);
            scene.add(o);
            Sys.players.push({
                id, obj: o, cam: c, inp, rotX: 0, 
                vel: new THREE.Vector3(0,0,0), onGround: false,
                hp: 100, lastHit: 0,
                model: steve
            });
        }

        function trySpawnZombie() {
            if(Sys.zombies.length >= 8) return;
            if(Math.random() > 0.4) return;
            const rx = Math.floor(Math.random() * WS);
            const rz = Math.floor(Math.random() * WS);
            if(map[rx][rz] === 0) {
                const px = (rx-WS/2)*BS;
                const pz = (rz-WS/2)*BS;
                let tooClose = false;
                Sys.players.forEach(p => { if(p.obj.position.distanceTo(new THREE.Vector3(px, 9, pz)) < 20) tooClose = true; });
                if(tooClose) return;
                const zObj = new THREE.Object3D();
                const zModel = createHumanoid(true);
                zModel.position.y = -9.0; 
                zObj.add(zModel);
                zObj.position.set(px, 9, pz);
                scene.add(zObj);
                Sys.zombies.push({ obj: zObj, hp: 3 });
            }
        }

        function attackZombie(playerIdx) {
            if(!Sys.players[playerIdx] || Sys.isGameOver) return;
            const p = Sys.players[playerIdx];
            p.cam.position.y -= 0.2; 
            setTimeout(()=>p.cam.position.y += 0.2, 50);
            for(let i=0; i<Sys.zombies.length; i++) {
                const z = Sys.zombies[i];
                // MESAFE ARTIRILDI: 8 -> 25
                if(z.obj.position.distanceTo(p.obj.position) < 25) {
                    z.hp--;
                    z.obj.children[0].children.forEach(mesh => {
                        if(mesh.material && mesh.material.emissive) mesh.material.emissive.setHex(0xff0000);
                    });
                    setTimeout(() => {
                         if(z.obj && z.obj.children[0]) z.obj.children[0].children.forEach(mesh => {
                            if(mesh.material && mesh.material.emissive) mesh.material.emissive.setHex(0x000000);
                        });
                    }, 200);
                    const knockback = new THREE.Vector3().subVectors(z.obj.position, p.obj.position).normalize().multiplyScalar(2);
                    z.obj.position.add(knockback);
                    if(z.hp <= 0) {
                        scene.remove(z.obj);
                        Sys.zombies.splice(i, 1);
                    }
                    break;
                }
            }
        }

        let mx=0, my=0;
        document.addEventListener('mousemove', e => { if(document.pointerLockElement) { mx+=e.movementX; my+=e.movementY; } });

        function checkCol(pos) {
            const padding = 1.2; 
            if(isWall(pos.x + padding, pos.z)) return true;
            if(isWall(pos.x - padding, pos.z)) return true;
            if(isWall(pos.x, pos.z + padding)) return true;
            if(isWall(pos.x, pos.z - padding)) return true;
            return false;
        }

        function isWall(x, z) {
            const gx = Math.round(x/BS + WS/2);
            const gz = Math.round(z/BS + WS/2);
            if(gx<0||gx>=WS||gz<0||gz>=WS) return true;
            return map[gx][gz] === 1;
        }

        function animate() {
            if(Sys.isGameOver) return;
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);
            const now = Date.now();

            Sys.players.forEach(p => {
                let inputX = 0, inputZ = 0, inputJump = false, rotY = 0, rotX = 0;
                if(p.inp.type === 'keyboard') {
                    if(keys['KeyW']) inputZ = -1; if(keys['KeyS']) inputZ = 1;
                    if(keys['KeyA']) inputX = -1; if(keys['KeyD']) inputX = 1;
                    if(keys['Space']) inputJump = true;
                    rotY = -mx * 0.006; rotX = -my * 0.006;
                }
                else if(p.inp.type === 'touch') {
                    inputX = TouchData.moveX; inputZ = TouchData.moveZ;
                    inputJump = TouchData.jump;
                    rotY = -TouchData.lookX * PHYS.lookSpeed; rotX = -TouchData.lookY * PHYS.lookSpeed;
                    if(TouchData.attack) { attackZombie(p.id-1); TouchData.attack = false; }
                    TouchData.lookX = 0; TouchData.lookY = 0;
                }
                else if(p.inp.type === 'gamepad') {
                    const gp = navigator.getGamepads()[p.inp.index];
                    if(gp) {
                        if(Math.abs(gp.axes[0])>0.1) inputX = gp.axes[0];
                        if(Math.abs(gp.axes[1])>0.1) inputZ = gp.axes[1];
                        if(gp.buttons[0].pressed) inputJump = true;
                        if(gp.buttons[2].pressed || gp.buttons[5].pressed) attackZombie(p.id-1);
                        if(Math.abs(gp.axes[2])>0.1) rotY = -gp.axes[2]*0.04;
                        if(Math.abs(gp.axes[3])>0.1) rotX = -gp.axes[3]*0.04;
                    }
                }

                p.obj.rotation.y += rotY;
                p.rotX = Math.max(-1.5, Math.min(1.5, p.rotX + rotX));
                p.cam.rotation.x = p.rotX;

                const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(p.obj.quaternion); forward.y = 0; forward.normalize();
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(p.obj.quaternion); right.y = 0; right.normalize();
                const moveDir = new THREE.Vector3();
                moveDir.addScaledVector(forward, inputZ); moveDir.addScaledVector(right, inputX);
                if(moveDir.length() > 1) moveDir.normalize();

                p.vel.x = moveDir.x * PHYS.speed;
                p.vel.z = moveDir.z * PHYS.speed;

                if(p.onGround) {
                    if(inputJump) { p.vel.y = PHYS.jumpForce; p.onGround = false; } else p.vel.y = 0;
                } else {
                    p.vel.y -= PHYS.gravity * dt;
                }

                p.obj.position.x += p.vel.x * dt;
                if(checkCol(p.obj.position)) p.obj.position.x -= p.vel.x * dt;
                p.obj.position.z += p.vel.z * dt;
                if(checkCol(p.obj.position)) p.obj.position.z -= p.vel.z * dt;
                p.obj.position.y += p.vel.y * dt;
                
                if(p.obj.position.y < 9.0) { p.obj.position.y = 9.0; p.onGround = true; p.vel.y = 0; } 
                else { p.onGround = false; }

                if(p.id === 1) {
                    const hpPercent = Math.max(0, p.hp);
                    document.getElementById('health-bar').style.width = hpPercent + '%';
                }
            });

            const zSpeed = 5.0;
            Sys.zombies.forEach(z => {
                let closestDist = 999;
                let target = null;
                Sys.players.forEach(p => {
                    const d = p.obj.position.distanceTo(z.obj.position);
                    if(d < closestDist) { closestDist = d; target = p; }
                });

                if(target && closestDist < 60) {
                    z.obj.lookAt(target.obj.position.x, 9, target.obj.position.z);
                    const fwd = new THREE.Vector3(0,0,1).applyQuaternion(z.obj.quaternion);
                    z.obj.position.addScaledVector(fwd, zSpeed * dt);
                    if(checkCol(z.obj.position)) z.obj.position.addScaledVector(fwd, -zSpeed * dt);

                    if(closestDist < 2.5) {
                        if(now - target.lastHit > 1000) { 
                            target.lastHit = now;
                            target.hp -= 20; 
                            const overlay = document.getElementById('damage-overlay');
                            overlay.style.opacity = 0.5;
                            setTimeout(() => overlay.style.opacity = 0, 100);
                            const knock = fwd.clone().multiplyScalar(10);
                            target.vel.add(knock);

                            if(target.hp <= 0) {
                                Sys.isGameOver = true;
                                document.exitPointerLock();
                                document.getElementById('game-over-screen').style.display = 'flex';
                                document.getElementById('touch-ui').style.display = 'none';
                            }
                        }
                    }
                }
            });

            if(InputMap.p1?.type==='keyboard') { mx=0; my=0; }

            const w=window.innerWidth, h=window.innerHeight;
            Sys.players.forEach((p,i)=>{
                if(p.model) p.model.visible = false;
                if(Sys.players.length === 1) {
                    p.cam.aspect=w/h; p.cam.updateProjectionMatrix();
                    renderer.setViewport(0,0,w,h); renderer.setScissor(0,0,w,h); renderer.setScissorTest(true);
                    renderer.render(scene, p.cam);
                } else {
                    const l=i===0?0:w/2;
                    p.cam.aspect=(w/2)/h; p.cam.updateProjectionMatrix();
                    renderer.setViewport(l,0,w/2,h); renderer.setScissor(l,0,w/2,h); renderer.setScissorTest(true);
                    renderer.render(scene, p.cam);
                }
                if(p.model) p.model.visible = true;
            });
        }
        window.addEventListener('resize', ()=>renderer.setSize(window.innerWidth, window.innerHeight));
    </script>
</body>
</html>
